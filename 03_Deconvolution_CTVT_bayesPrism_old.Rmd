---
title: "01_Deconvolution_bayesPrism"
author: "IMEV2"
date: "`r Sys.Date()`"
output: html_document
---

# 0 Environment
## 0.1 Packages
### 0.1.1 Installs
```{r echo=F, message=F, warning=FALSE}
# if (!requireNamespace("devtools", quietly = TRUE)) {
#    install.packages("devtools")
# }
# devtools::install_github("Danko-Lab/BayesPrism/BayesPrism")
```
### 0.1.1 Library
```{r echo=F, message=F, warning=FALSE}
set.seed(123)
library(BayesPrism)
library(tidyverse)
library(SingleCellExperiment)
library(openxlsx)
library(patchwork)
library(pheatmap)
library(ComplexHeatmap)
library(circlize)
setClassUnion("ExpData", c("matrix", "SummarizedExperiment"))
```

## 0.2 Paths
```{r echo=F, message=FALSE, warning=FALSE}
fprefix <- "03_Deconvolution_CTVT_bayesPrism"
wDir <- paste0("~/gitClones/01_Deconvolution/03_Deconvolution_CTVT/")
dataDir <- paste0(wDir, "/031_Data/")
resDir <- paste0(wDir, "/033_Results/", fprefix, "/")
plotDir <- paste0(wDir, "/034_Plots/", fprefix, "/")

dir.create(resDir)
dir.create(plotDir)

scriptDir <- paste0(wDir, "/032_Scripts/03_Deconvolution_CTVT_deconBenchmark/")
source(paste0(scriptDir, "03_Deconvolution_CTVT_deconBenchmark_metrics.R"))
```

# 1.0 Inputs
BayesPrism will take intersect of genes in reference and bulk samples.
Use unnormalized and untransformed count data.

## 1.1 Genes of interest
Mixed curated and non-curated list. 
```{r}
# adrianq1q4100 <- read.xlsx("~/gitClones/01_Deconvolution/03_Deconvolution_CTVT/033_Results/03_Deconvolution_CTVT_geneCorrelations/03_Deconvolution_CTVT_geneCorrelations_mergedFamWilcoxDegs_q1q4_100Genes.xlsx") 
# 
# goi <- unique(adrianq1q4100$Symbol)
# idoi <- unique(adrianq1q4100$GeneID)
# 
# geneDict <- adrianq1q4100 %>%
#   select(Symbol, GeneID) %>%
#   # Take distinct as marker genes may overlap clusters. 
#   distinct()

masterMarkerGenes <- read.xlsx("~/gitClones/01_Deconvolution/03_Deconvolution_CTVT/033_Results/03_Deconvolution_CTVT_geneCorrelations/03_Deconvolution_CTVT_geneCorrelations_masterMarkerGenes.xlsx")

geneDict <- masterMarkerGenes %>%
  select(Symbol, GeneID) %>%
  # Take distinct as marker genes may overlap clusters.
  distinct()

```


## 1.2 Reference
Reference - cellxgene dense matrix.
### 1.2.1 Matrix
```{r}
obj <- readRDS(paste0(dataDir, "SCE_concat_CTVT_includingAllGenes_logCorrecDone_vstCorrecDone_ClustDone2_ManAnot.rds"))

objNoBad <- obj[,obj$manual.log.anot.fine!="bad"]

rm(obj)
gc()

snCountsFinal <- counts(objNoBad) %>%
  as.data.frame() %>%
  rownames_to_column("Symbol") %>%
  filter(Symbol %in% geneDict$Symbol) %>%
  column_to_rownames("Symbol") 
  

colData <- colData(objNoBad)
rm(objNoBad)
gc()
```

### 1.1.2 Cell type annotations
Cell type labels - character vector same length as # cells in reference.
Cell state labels - optional, finer granularity character vector. (i.e. myeloid 1 vs myeloid 2). 
Labels should have at least 20 to 50 cells. 
```{r}
snCountsFinal_colData <- colData

snAnno <- snCountsFinal_colData$manual.log.anot.fine
print(ncol(snCountsFinal)==length(snAnno))
print(sort(table(snAnno)))

# Create the cell count matrix: rows = cell types, columns = samples
snCellCounts <- snCountsFinal_colData %>%
  as.data.frame() %>%
  dplyr::group_by(manual.log.anot.fine, 
           Sample) %>%
  summarise(cellCount = n()) %>%
  pivot_wider(names_from = Sample, 
              values_from = cellCount, 
              values_fill = 0) %>%
  column_to_rownames("manual.log.anot.fine")

# Convert to percentages (column-wise normalization)
snCellPercentages <- sweep(snCellCounts, 
                           2, 
                           colSums(snCellCounts), 
                           FUN = "/") %>%
  round(3) %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(
    cols = -sample,
    names_to = "manual.log.anot.fine",
    values_to = "cellProportion"
  ) %>%
  # If sample name ends in b_n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
  mutate(
    sampleType = "sn",
    sampleName = sample, 
    sampleNameEdit = str_remove(sampleName, "[ab]")
  ) %>%
  select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
  mutate("deconvBenchResType" = "groundTruth", # P for proportion
         "Method" = "NA", 
         "Parameters" = "NA", 
         "Reference" = "full",
         "Seed"=123)
```

## 1.3 Bulk
### 1.2.1 Matrix
```{r}
bulkCountsFinal <- readRDS(paste0(dataDir, "01_Deconvolution_matchedBulkMatrixCTVT_bulkCountsFinal.rds")) %>%
  as.data.frame() %>%
  # select gene id's (stored as columns in df) that are hvgs.
  rownames_to_column("GeneID") %>%
  filter(GeneID %in% geneDict$GeneID) %>%
  left_join(geneDict) %>%
  column_to_rownames("Symbol") %>%
  select(-GeneID) %>%
  as.matrix()
```
### 1.3.2 Metadata
```{r}
bulkCountsFinal_metadata <- read.xlsx(paste0(dataDir, "01_Deconvolution_matchedBulkMatrixCTVT_bulkCountsFinal_metadata.xlsx"))
```

## 1.5 Transpose all matrices for BayesPrism
BayesPrism takes a sample x gene matrix (rather than gene x sample, as is default.)
```{r}
bulkCountsFinal <- bulkCountsFinal[rownames(snCountsFinal),] %>%
  t()

snCountsFinal <- snCountsFinal %>%
  t()

gc()



snCountsFinalUnique <- snCountsFinal[, masterMarkerGenes[which(masterMarkerGenes$Unique=="Unique"),]$Symbol]

bulkCountsFinalUnique <- bulkCountsFinal[, masterMarkerGenes[which(masterMarkerGenes$Unique=="Unique"),]$Symbol]
  

gc()
```

## 1.6 Create masterDf's
```{r}
masterPropDf <- data.frame(sampleName = c(), 
                           sampleType = c(), 
                           manual.log.anot.fine = c(), 
                           cellProportion =c(), 
                           sampleNameEdit = c(), 
                           deconvBenchResType = c(), 
                           Method = c(), 
                           Parameters = c())


# masterMetricDf <- data.frame(bulkCellEstimate = c(), 
#                              bulkNucEstimate = c(), 
#                              Method = c(), 
#                              Parameters = c(), 
#                              Metric = c())

masterGlobMetricDf <- data.frame(bulkCellEstimate = c(),
                             bulkNucEstimate = c(),
                             Method = c(),
                             Parameters = c(),
                             Metric = c())

masterGranularMetricDf <- data.frame(
  Metric = c(),
  Value = c(),
  Subject = c(),
  Estimate = c()
)

masterRawPEDf <- data.frame(
  Colname = c(),
  Rowname = c(),
  Estimate = c(),
  Method = c(),
  Parameters = c(),
  Reference = c(),
  Seed = c()
)

```



# 2.0 QC of annotations. 
## 2.1 Correlation between cell types and subtypes
```{r}
plot.cor.phi(input = snCountsFinal,
                         input.labels=snAnno,
                         title=paste0(fprefix, " ", "snAnno"),
                         #specify pdf.prefix if need to output to pdf
                         pdf.prefix=paste0(plotDir, fprefix, "_snAnno_pwCorrMatrix"), 
                         cexRow=0.5, cexCol=0.5,
                         margins=c(4,4)) # Good separation between cell types.

plot.cor.phi(input = snCountsFinalUnique,
                         input.labels=snAnno,
                         title=paste0(fprefix, " ", "snAnno"),
                         #specify pdf.prefix if need to output to pdf
                         pdf.prefix=paste0(plotDir, fprefix, "_snAnno_pwCorrMatrix_uniqueGenes"), 
                         cexRow=0.5, cexCol=0.5,
                         margins=c(4,4)) 


# # Uncomment if using subtypes.
# plot.cor.phi (input=sc.dat, 
#                          input.labels=cell.type.labels, 
#                          title="cell type correlation",
#                          #specify pdf.prefix if need to output to pdf
#                          #pdf.prefix="gbm.cor.ct",
#                          cexRow=0.5, cexCol=0.5,
#                          )
```
## 2.2 Filter outlier genes
Not supported for non Hs or Mm genomes. 
TODO: Check functions --> use MSarHar reference. 
### 2.2.1 Reference
- Visualize ribosomal proteins, mt ribosomal proteins, ribosomal pseudogenes, chrM, Actin, Hemoglobin, MALAT1?
- - TODO: Plot max expr spec vs log mean expr. 
- - TODO: Check outlier genes in Maurine's script. 
```{r}
# sc.stat <- plot.scRNA.outlier(input=sc.dat, #make sure the colnames are gene symbol or ENSMEBL ID 
#   cell.type.labels=cell.type.labels,
#   species="hs", #currently only human(hs) and mouse(mm) annotations are supported
#   return.raw=TRUE #return the data used for plotting. 
#   #pdf.prefix="gbm.sc.stat" specify pdf.prefix if need to output to pdf
# )
```
### 2.2.2 Bulk
-- TODO: Bulk plot
```{r}
bk.stat <- plot.bulk.outlier(
  bulk.input = bulkCountsFinal,
  sc.input = snCountsFinal,
  cell.type.labels=snAnno
)
```
### 2.2.3 Filter outlier genes from reference
- Remove gene groups (i.e. Rb, Mrp, ...)
-- TODO: Check if this is necessary, leaning towards just taking filtered gene list from Maurine. 
### 2.2.4 Concordance of gene expression 
-- TODO: Plots for our data separated by protein coding, lncRNA, and pseudogenes. 
-- TODO: If applicable, only keep protein coding genes?
### 2.2.5 FindMarker (BioConductor)
-- But because Maurine has run these kinds of function to perform clustering/annotation, I think we are better off just taking filtered gene list/HVGs from pre-processing diagrams. Need to check this. 
- Find markers within subtypes within each type. 
```{r}
# diff.exp.stat <- get.exp.stat(sc.dat=snCountsFinal[,colSums(snCountsFinal>0)>3],# filter genes to reduce memory use. Columns are genes (opposite to Seurat/CellRanger/SCE etc.)
#                                           cell.type.labels=snAnno,
#                                           pseudo.count=0.1, #a numeric value used for log2 transformation. =0.1 for 10x data, =10 for smart-seq. Default=0.1.
#                                           cell.count.cutoff=50, # a numeric value to exclude cell state with number of cells fewer than this value for t test. Default=50.
#                                           n.cores=1 #number of threads
#                                           )
```
### 2.2.6 Subset reference for marker genes only
- Option to run select.marker. 
- Instead, taking marker genes from Maurine. The sn matrix already has filtered because it came from integrated (03 in shared OneDrive). Perhaps filter more?
- Of note: final matrix also needs to have genes in columns!

```{r}
# dim(snCountsFinal)
```
# ---- Version 1 ----

# 3 Prism - "full"
## 3.1key = Null 
There is an option, key, to define the label that corresponds to the tumor. It should be NULL if there are no tumor cells OR if the reference and mixture are from matched sample. I'm not sure what this means for when we have non-matched samples so creating two prisms. 
-- TODO: Check if its okay to define state and type labels as the same thing. Because the map will return correspondence between cell type and cell state/subtype. 

### 3.1.1 masterMarkerGenes
```{r}
myPrismNull <- new.prism(
  reference = snCountsFinal, 
  mixture = bulkCountsFinal, 
  cell.type.labels = snAnno, 
  cell.state.labels = snAnno,
  key = NULL, 
  outlier.cut = 0.8, # Filter genes in the bulk sample with an expression fraction greater than 1% in more than 10% of bulk data. These genes may dominate as outliers resulting from less stringent QC after mapping. 
  outlier.fraction = 0.00
)
# Print genes filtered out

filtered <- setdiff(colnames(snCountsFinal), colnames(myPrismNull@mixture))

bpResNull <- run.prism(prism = myPrismNull, 
                       n.cores=8)
slotNames(bpResNull)


# extract posterior mean of cell type fraction theta
thetaFirstNull <- get.fraction(bp=bpResNull,
            which.theta="first", # After Gibbs
            state.or.type="type")

head(thetaFirstNull)

# Pivot to long format
bulkPercentagesFirstNull <- thetaFirstNull %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(
    cols = -sample,
    names_to = "manual.log.anot.fine",
    values_to = "cellProportion"
  ) %>%
  # If sample name ends in _n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
  mutate(
    sampleType = case_when(
      str_ends(sample, "_n") ~ "bn",
      TRUE ~ "bc"
    ),
    # If sample type is bn, remove b_n to save sample id only. 
    sampleName = case_when(
      sampleType == "bn" ~ str_remove(sample, "_n$"),
      TRUE ~ sample
    ), 
    # If sample type is bn, remove a or b from the end of the sample name. 
    sampleNameEdit = case_when(
      sampleType == "bn" ~ str_remove(sampleName, "[ab]"),
      TRUE ~ sampleName
    ),
  ) %>%
  select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
  # Method details
  mutate("deconvBenchResType" = "P", # P for proportion
         "Method" = "customBayesPrism", 
         "Parameters" = "keyNullThetaFirst",
         "Reference" = "masterMarkerAll",
         "Seed"=123)

# Rbind proportion outputs to compute error metrics.
bayesResGround <- rbind(bulkPercentagesFirstNull,
                        snCellPercentages)

# Reference will change for the four Prism situations, so not including in the masterPropDf. Instead, inlcluding notes in "Reference" column. 
masterPropDf <- rbind(masterPropDf, 
                      bulkPercentagesFirstNull)

# Compute and rbind metric outputs
bayesResMetrics <- deconError(bayesResGround, 
                              parameters = "keyNullThetaFirst",
                              method = "customBayesPrism",
                              reference="masterMarkerAll",
                              seed=123)
# Rbind metric measurements 
 masterGlobMetricDf <- rbind(masterGlobMetricDf, 
                              bayesResMetrics$overviewMetrics)
masterGranularMetricDf <- rbind(masterGranularMetricDf, 
                              bayesResMetrics$granularMetrics)
masterRawPEDf <- rbind(masterRawPEDf, 
                              bayesResMetrics$rawPredictionError)

# Cleanup
rm(thetaFirstNull, bulkPercentagesFirstNull, bayesResGround, bayesResMetrics)
gc()

# extract posterior mean of cell type fraction theta
thetaNullFinal <- get.fraction (bp=bpResNull,
            which.theta="final", # After Gibbs
            state.or.type="type")

head(thetaNullFinal)

# Pivot to long format
bulkPercentagesFinalNull <- thetaNullFinal %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(
    cols = -sample,
    names_to = "manual.log.anot.fine",
    values_to = "cellProportion"
  ) %>%
  # If sample name ends in _n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
  mutate(
    sampleType = case_when(
      str_ends(sample, "_n") ~ "bn",
      TRUE ~ "bc"
    ),
    # If sample type is bn, remove b_n to save sample id only. 
    sampleName = case_when(
      sampleType == "bn" ~ str_remove(sample, "_n$"),
      TRUE ~ sample
    ), 
    # If sample type is bn, remove a or b from the end of the sample name. 
    sampleNameEdit = case_when(
      sampleType == "bn" ~ str_remove(sampleName, "[ab]"),
      TRUE ~ sampleName
    ),
  ) %>%
  select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
  # Method details
  mutate("deconvBenchResType" = "P", # P for proportion
         "Method" = "customBayesPrism", 
         "Parameters" = "keyNullThetaFinal",
         "Reference" = "masterMarkerAll",
         "Seed"=123)

# Rbind proportion outputs to compute error metrics.
bayesResGround <- rbind(bulkPercentagesFinalNull,
                        snCellPercentages)

# Reference will change for the four Prism situations, so not including in the masterPropDf. Instead, inlcluding notes in "Reference" column. 
masterPropDf <- rbind(masterPropDf, 
                      bulkPercentagesFinalNull)

# Compute and rbind metric outputs
bayesResMetrics <- deconError(bayesResGround, 
                              parameters = "keyNullThetaFinal",
                              method = "customBayesPrism",
                              reference="masterMarkerAll",
                              seed=123)
# Rbind metric measurements 
 masterGlobMetricDf <- rbind(masterGlobMetricDf, 
                              bayesResMetrics$overviewMetrics)
masterGranularMetricDf <- rbind(masterGranularMetricDf, 
                              bayesResMetrics$granularMetrics)
masterRawPEDf <- rbind(masterRawPEDf, 
                              bayesResMetrics$rawPredictionError)

# Cleanup
rm(thetaFinalNull, bulkPercentagesFinalNull, bayesResGround, bayesResMetrics, myPrismNull, bpResNull)
gc()
```

### 3.1.1 masterMarkerGenes Unique
```{r}
myPrismNull <- new.prism(
  reference = snCountsFinalUnique, 
  mixture = bulkCountsFinalUnique, 
  cell.type.labels = snAnno, 
  cell.state.labels = snAnno,
  key = NULL, 
  outlier.cut = 0.8, # Filter genes in the bulk sample with an expression fraction greater than 1% in more than 10% of bulk data. These genes may dominate as outliers resulting from less stringent QC after mapping. 
  outlier.fraction = 0.00
)
# Print genes filtered out

filtered <- setdiff(colnames(snCountsFinal), colnames(myPrismNull@mixture))

bpResNull <- run.prism(prism = myPrismNull, 
                       n.cores=8)
slotNames(bpResNull)


# extract posterior mean of cell type fraction theta
thetaFirstNull <- get.fraction(bp=bpResNull,
            which.theta="first", # After Gibbs
            state.or.type="type")

head(thetaFirstNull)

# Pivot to long format
bulkPercentagesFirstNull <- thetaFirstNull %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(
    cols = -sample,
    names_to = "manual.log.anot.fine",
    values_to = "cellProportion"
  ) %>%
  # If sample name ends in _n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
  mutate(
    sampleType = case_when(
      str_ends(sample, "_n") ~ "bn",
      TRUE ~ "bc"
    ),
    # If sample type is bn, remove b_n to save sample id only. 
    sampleName = case_when(
      sampleType == "bn" ~ str_remove(sample, "_n$"),
      TRUE ~ sample
    ), 
    # If sample type is bn, remove a or b from the end of the sample name. 
    sampleNameEdit = case_when(
      sampleType == "bn" ~ str_remove(sampleName, "[ab]"),
      TRUE ~ sampleName
    ),
  ) %>%
  select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
  # Method details
  mutate("deconvBenchResType" = "P", # P for proportion
         "Method" = "customBayesPrism", 
         "Parameters" = "keyNullThetaFirst",
         "Reference" = "masterMarkerUnique",
         "Seed"=123)

# Rbind proportion outputs to compute error metrics.
bayesResGround <- rbind(bulkPercentagesFirstNull,
                        snCellPercentages)

# Reference will change for the four Prism situations, so not including in the masterPropDf. Instead, inlcluding notes in "Reference" column. 
masterPropDf <- rbind(masterPropDf, 
                      bulkPercentagesFirstNull)

# Compute and rbind metric outputs
bayesResMetrics <- deconError(bayesResGround, 
                              parameters = "keyNullThetaFirst",
                              method = "customBayesPrism",
                              reference="masterMarkerUnique",
                              seed=123)
# Rbind metric measurements 
 masterGlobMetricDf <- rbind(masterGlobMetricDf, 
                              bayesResMetrics$overviewMetrics)
masterGranularMetricDf <- rbind(masterGranularMetricDf, 
                              bayesResMetrics$granularMetrics)
masterRawPEDf <- rbind(masterRawPEDf, 
                              bayesResMetrics$rawPredictionError)

# Cleanup
rm(thetaFirstNull, bulkPercentagesFirstNull, bayesResGround, bayesResMetrics)
gc()

# extract posterior mean of cell type fraction theta
thetaNullFinal <- get.fraction (bp=bpResNull,
            which.theta="final", # After Gibbs
            state.or.type="type")

head(thetaNullFinal)

# Pivot to long format
bulkPercentagesFinalNull <- thetaNullFinal %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(
    cols = -sample,
    names_to = "manual.log.anot.fine",
    values_to = "cellProportion"
  ) %>%
  # If sample name ends in _n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
  mutate(
    sampleType = case_when(
      str_ends(sample, "_n") ~ "bn",
      TRUE ~ "bc"
    ),
    # If sample type is bn, remove b_n to save sample id only. 
    sampleName = case_when(
      sampleType == "bn" ~ str_remove(sample, "_n$"),
      TRUE ~ sample
    ), 
    # If sample type is bn, remove a or b from the end of the sample name. 
    sampleNameEdit = case_when(
      sampleType == "bn" ~ str_remove(sampleName, "[ab]"),
      TRUE ~ sampleName
    ),
  ) %>%
  select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
  # Method details
  mutate("deconvBenchResType" = "P", # P for proportion
         "Method" = "customBayesPrism", 
         "Parameters" = "keyNullThetaFinal",
         "Reference" = "masterMarkerUnique",
         "Seed"=123)

# Rbind proportion outputs to compute error metrics.
bayesResGround <- rbind(bulkPercentagesFinalNull,
                        snCellPercentages)

# Reference will change for the four Prism situations, so not including in the masterPropDf. Instead, inlcluding notes in "Reference" column. 
masterPropDf <- rbind(masterPropDf, 
                      bulkPercentagesFinalNull)

# Compute and rbind metric outputs
bayesResMetrics <- deconError(bayesResGround, 
                              parameters = "keyNullThetaFinal",
                              method = "customBayesPrism",
                              reference="masterMarkerUnique",
                              seed=123)
# Rbind metric measurements 
 masterGlobMetricDf <- rbind(masterGlobMetricDf, 
                              bayesResMetrics$overviewMetrics)
masterGranularMetricDf <- rbind(masterGranularMetricDf, 
                              bayesResMetrics$granularMetrics)
masterRawPEDf <- rbind(masterRawPEDf, 
                              bayesResMetrics$rawPredictionError)

# Cleanup
rm(thetaFinalNull, bulkPercentagesFinalNull, bayesResGround, bayesResMetrics, myPrismNull, bpResNull)
gc()
```

## 3.2 key = "CTVT"
There is an option, key, to define the label that corresponds to the tumor. It should be NULL if there are no tumor cells OR if the reference and mixture are from matched sample.
I'm not sure what this means for when we have non-matched samples so creating two prisms. 
### 3.2.1 Master marker all
```{r}
myPrismKey <- new.prism(
  reference = snCountsFinal, 
  mixture = bulkCountsFinal, 
  cell.type.labels = snAnno, 
  cell.state.labels = snAnno,
  key = "CTVT", 
  outlier.cut = 0.8, # Filter genes in the bulk sample with an expression fraction greater than 1% in more than 10% of bulk data. These genes may dominate as outliers resulting from less stringent QC after mapping. 
  outlier.fraction = 0
)

# Number of outlier genes filtered from mixture = 50 genes have an expression fraction greater than 1 in more than 10 of bulk data. 

bpResKey <- run.prism(prism = myPrismKey, 
                       n.cores=8)

# extract posterior mean of cell type fraction theta
thetaFirstKey <- get.fraction (bp=bpResKey,
            which.theta="first", # After Gibbs
            state.or.type="type")

head(thetaFirstKey)

# Pivot to long format
bulkPercentagesFirstKey <- thetaFirstKey %>%
   as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(
    cols = -sample,
    names_to = "manual.log.anot.fine",
    values_to = "cellProportion"
  ) %>%
  # If sample name ends in _n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
  mutate(
    sampleType = case_when(
      str_ends(sample, "_n") ~ "bn",
      TRUE ~ "bc"
    ),
    # If sample type is bn, remove b_n to save sample id only. 
    sampleName = case_when(
      sampleType == "bn" ~ str_remove(sample, "_n$"),
      TRUE ~ sample
    ), 
    # If sample type is bn, remove a or b from the end of the sample name. 
    sampleNameEdit = case_when(
      sampleType == "bn" ~ str_remove(sampleName, "[ab]"),
      TRUE ~ sampleName
    ),
  ) %>%
  select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
  # Method details
  mutate("deconvBenchResType" = "P", # P for proportion
         "Method" = "customBayesPrism", 
         "Parameters" = "keyCTVTThetaFirst",
         "Reference" = "masterMarkerAll",
         "Seed"=123)

# Rbind proportion outputs to compute error metrics.
bayesResGround <- rbind(bulkPercentagesFirstKey,
                        snCellPercentages)

# Reference will change for the four Prism situations, so not including in the masterPropDf. Instead, inlcluding notes in "Reference" column. 
masterPropDf <- rbind(masterPropDf, 
                      bulkPercentagesFirstKey)

# Compute and rbind metric outputs
bayesResMetrics <- deconError(bayesResGround, 
                              parameters = "keyCTVTThetaFirst",
                              method = "customBayesPrism",
                              reference="masterMarkerAll",
                              seed=123)
# Rbind metric measurements 
# Rbind metric measurements 
 masterGlobMetricDf <- rbind(masterGlobMetricDf, 
                              bayesResMetrics$overviewMetrics)
masterGranularMetricDf <- rbind(masterGranularMetricDf, 
                              bayesResMetrics$granularMetrics)
masterRawPEDf <- rbind(masterRawPEDf, 
                              bayesResMetrics$rawPredictionError)

# Cleanup
rm(thetaFirstKey, bulkPercentagesFirstKey, bayesResGround, bayesResMetrics)
gc()


# extract posterior mean of cell type fraction theta
thetaFinalKey <- get.fraction (bp=bpResKey,
            which.theta="final", # After Gibbs
            state.or.type="type")

head(thetaFinalKey)

# Pivot to long format
bulkPercentagesFinalKey <- thetaFinalKey %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(
    cols = -sample,
    names_to = "manual.log.anot.fine",
    values_to = "cellProportion"
  ) %>%
  # If sample name ends in _n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
  mutate(
    sampleType = case_when(
      str_ends(sample, "_n") ~ "bn",
      TRUE ~ "bc"
    ),
    # If sample type is bn, remove b_n to save sample id only. 
    sampleName = case_when(
      sampleType == "bn" ~ str_remove(sample, "_n$"),
      TRUE ~ sample
    ), 
    # If sample type is bn, remove a or b from the end of the sample name. 
    sampleNameEdit = case_when(
      sampleType == "bn" ~ str_remove(sampleName, "[ab]"),
      TRUE ~ sampleName
    ),
  ) %>%
  select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
  # Method details
  mutate("deconvBenchResType" = "P", # P for proportion
         "Method" = "customBayesPrism", 
         "Parameters" = "keyCTVTThetaFinal",
         "Reference" = "masterMarkerAll",
         "Seed"=123)

# Rbind proportion outputs to compute error metrics.
bayesResGround <- rbind(bulkPercentagesFinalKey,
                        snCellPercentages)

# Reference will change for the four Prism situations, so not including in the masterPropDf. Instead, inlcluding notes in "Reference" column. 
masterPropDf <- rbind(masterPropDf, 
                      bulkPercentagesFinalKey)

# Compute and rbind metric outputs
bayesResMetrics <- deconError(bayesResGround, 
                              parameters = "keyCTVTThetaFinal",
                              method = "customBayesPrism",
                              reference="masterMarkerAll",
                              seed=123)

 masterGlobMetricDf <- rbind(masterGlobMetricDf, 
                              bayesResMetrics$overviewMetrics)
masterGranularMetricDf <- rbind(masterGranularMetricDf, 
                              bayesResMetrics$granularMetrics)
masterRawPEDf <- rbind(masterRawPEDf, 
                              bayesResMetrics$rawPredictionError)
# Cleanup
rm(thetaFinalKey, bulkPercentagesFinalKey, bayesResGround, bayesResMetrics, myPrismKey, bpResKey)

gc()
```

### 3.2.2 Master marker unique
```{r}
myPrismKey <- new.prism(
  reference = snCountsFinalUnique, 
  mixture = bulkCountsFinalUnique, 
  cell.type.labels = snAnno, 
  cell.state.labels = snAnno,
  key = "CTVT", 
  outlier.cut = 0.8, # Filter genes in the bulk sample with an expression fraction greater than 1% in more than 10% of bulk data. These genes may dominate as outliers resulting from less stringent QC after mapping. 
  outlier.fraction = 0
)

# Number of outlier genes filtered from mixture = 50 genes have an expression fraction greater than 1 in more than 10 of bulk data. 

bpResKey <- run.prism(prism = myPrismKey, 
                       n.cores=8)

# extract posterior mean of cell type fraction theta
thetaFirstKey <- get.fraction (bp=bpResKey,
            which.theta="first", # After Gibbs
            state.or.type="type")

head(thetaFirstKey)

# Pivot to long format
bulkPercentagesFirstKey <- thetaFirstKey %>%
   as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(
    cols = -sample,
    names_to = "manual.log.anot.fine",
    values_to = "cellProportion"
  ) %>%
  # If sample name ends in _n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
  mutate(
    sampleType = case_when(
      str_ends(sample, "_n") ~ "bn",
      TRUE ~ "bc"
    ),
    # If sample type is bn, remove b_n to save sample id only. 
    sampleName = case_when(
      sampleType == "bn" ~ str_remove(sample, "_n$"),
      TRUE ~ sample
    ), 
    # If sample type is bn, remove a or b from the end of the sample name. 
    sampleNameEdit = case_when(
      sampleType == "bn" ~ str_remove(sampleName, "[ab]"),
      TRUE ~ sampleName
    ),
  ) %>%
  select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
  # Method details
  mutate("deconvBenchResType" = "P", # P for proportion
         "Method" = "customBayesPrism", 
         "Parameters" = "keyCTVTThetaFirst",
         "Reference" = "masterMarkerUnique",
         "Seed"=123)

# Rbind proportion outputs to compute error metrics.
bayesResGround <- rbind(bulkPercentagesFirstKey,
                        snCellPercentages)

# Reference will change for the four Prism situations, so not including in the masterPropDf. Instead, inlcluding notes in "Reference" column. 
masterPropDf <- rbind(masterPropDf, 
                      bulkPercentagesFirstKey)

# Compute and rbind metric outputs
bayesResMetrics <- deconError(bayesResGround, 
                              parameters = "keyCTVTThetaFirst",
                              method = "customBayesPrism",
                              reference="masterMarkerUnique",
                              seed=123)
# Rbind metric measurements 
# Rbind metric measurements 
 masterGlobMetricDf <- rbind(masterGlobMetricDf, 
                              bayesResMetrics$overviewMetrics)
masterGranularMetricDf <- rbind(masterGranularMetricDf, 
                              bayesResMetrics$granularMetrics)
masterRawPEDf <- rbind(masterRawPEDf, 
                              bayesResMetrics$rawPredictionError)

# Cleanup
rm(thetaFirstKey, bulkPercentagesFirstKey, bayesResGround, bayesResMetrics)
gc()


# extract posterior mean of cell type fraction theta
thetaFinalKey <- get.fraction (bp=bpResKey,
            which.theta="final", # After Gibbs
            state.or.type="type")

head(thetaFinalKey)

# Pivot to long format
bulkPercentagesFinalKey <- thetaFinalKey %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(
    cols = -sample,
    names_to = "manual.log.anot.fine",
    values_to = "cellProportion"
  ) %>%
  # If sample name ends in _n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
  mutate(
    sampleType = case_when(
      str_ends(sample, "_n") ~ "bn",
      TRUE ~ "bc"
    ),
    # If sample type is bn, remove b_n to save sample id only. 
    sampleName = case_when(
      sampleType == "bn" ~ str_remove(sample, "_n$"),
      TRUE ~ sample
    ), 
    # If sample type is bn, remove a or b from the end of the sample name. 
    sampleNameEdit = case_when(
      sampleType == "bn" ~ str_remove(sampleName, "[ab]"),
      TRUE ~ sampleName
    ),
  ) %>%
  select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
  # Method details
  mutate("deconvBenchResType" = "P", # P for proportion
         "Method" = "customBayesPrism", 
         "Parameters" = "keyCTVTThetaFinal",
         "Reference" = "masterMarkerUnique",
         "Seed"=123)

# Rbind proportion outputs to compute error metrics.
bayesResGround <- rbind(bulkPercentagesFinalKey,
                        snCellPercentages)

# Reference will change for the four Prism situations, so not including in the masterPropDf. Instead, inlcluding notes in "Reference" column. 
masterPropDf <- rbind(masterPropDf, 
                      bulkPercentagesFinalKey)

# Compute and rbind metric outputs
bayesResMetrics <- deconError(bayesResGround, 
                              parameters = "keyCTVTThetaFinal",
                              method = "customBayesPrism",
                              reference="masterMarkerUnique",
                              seed=123)

 masterGlobMetricDf <- rbind(masterGlobMetricDf, 
                              bayesResMetrics$overviewMetrics)
masterGranularMetricDf <- rbind(masterGranularMetricDf, 
                              bayesResMetrics$granularMetrics)
masterRawPEDf <- rbind(masterRawPEDf, 
                              bayesResMetrics$rawPredictionError)
# Cleanup
rm(thetaFinalKey, bulkPercentagesFinalKey, bayesResGround, bayesResMetrics, myPrismKey, bpResKey)

gc()
```


# 7 Update prisms for batch effect from sn vs bulk cell?
Update prism function should account for "batch" effect of sn vs sc. We can test how well this works by comparing cell vs nuc and with and without update prism. If nuc without update looks similar to cell with update prism, this would indicate update prism can capture differences. 

- Update prism is stored in which.theta = final.

# 8 Embedding learning
Could be interesting to understand tumor subset expression in bulk with removal of inferred immune cell subsets. 

# 9 Export results
```{r}
openxlsx::write.xlsx(masterPropDf, 
           paste0(resDir, fprefix, "_masterProportionDf.xlsx"))
write.xlsx(masterGlobMetricDf, 
           paste0(resDir, fprefix, "_masterGlobalMetricDf.xlsx"))
write.xlsx(masterGranularMetricDf, 
           paste0(resDir, fprefix, "_masterGranularMetricDf.xlsx"))
write.xlsx(masterRawPEDf, 
           paste0(resDir, fprefix, "_masterRawPEDf.xlsx"))
```



# ----

# 5 Visualizations 
## 5.1 Read in results 
```{r}
masterPropDf <- read.xlsx(paste0(resDir, fprefix, "_masterProportionDf.xlsx"), sheet=2) %>%
  mutate("Method_Param"=paste0(Method, "_", Parameters), 
         "Method_Param_Reference" = paste0(Method_Param, "_", Reference))

masterMetricDf <- read.xlsx(paste0(resDir, fprefix, "_masterMetricDf.xlsx"), 
                            sheet=2) %>%
  mutate("Method_Param"=paste0(Method, "_", Parameters), 
         "Method_Param_Reference" = paste0(Method_Param, "_", Reference))
```

## 5.2 Metrics 
```{r}
# Of note, not all bulk samples were in snData
# > setdiff(dfPred$sampleNameEdit, dfTruth$sampleNameEdit)
# [1] "3177T4" "3177T5" "3177T6"
# > # Weirdly, saving with write.xlsx preserves rownames, but can't read them in? 
# > snCountsFinal_colData <- read.xlsx(paste0(dataDir, "01_Deconvolution_geneAnnotationsCTVTRefsnCountsFinal_colData.xlsx"))
# > bulkCountsFinal_metadata <- read.xlsx(paste0(dataDir, "01_Deconvolution_matchedBulkMatrixCTVTf_bulkCountsFinal_metadata.xlsx"))
# > View(bulkCountsFinal_metadata)
# > setdiff(bulkCountsFinal_metadata$sampleName, snCountsFinal_colData$Sample)
#  [1] "3176T3"    "3176T3b_n" "3177T2"    "3177T2a_n" "3177T4"    "3177T4a_n" "3177T5"    "3177T5a_n" "3177T6"    "3177T6a_n"
# [11] "3178T1"    "3178T1b_n" "3179T2"    "3179T2a_n" "3179T3"    "3179T3a_n" "3180T3"    "3180T3a_n" "3181T1"    "3181T1a_n"
# --> "3177T4"    "3177T4a_n"
# --> "3177T5"    "3177T5a_n"
# --> "3177T6"    "3177T6a_n"
```

### 5.2.1 RMSE
#### 5.2.1.1 Heatmap functions
Inspired by https://www.nature.com/articles/s41467-023-41385-5#Fig3. 
Takes average, should we take median? 
```{r}
rmseByCellTypeMean <- function(df, pred_type) {
  
  dfPred <- df %>%
    filter(sampleType %in% c(pred_type)) %>%
    select(sampleNameEdit, 
           sampleName, 
           manual.log.anot.fine, 
           cellProportion, 
           Method_Param)
  
  dfTruth <- df %>%
    filter(sampleType == "sn") %>%
    select(sampleNameEdit, 
           sampleName, 
           manual.log.anot.fine, 
           cellProportion) %>%
    dplyr::rename(truth = cellProportion)
  
  # 7 single-cell samples, 10 bulk cell and 10 bulk nuc samples. 
  intersect <- intersect(dfPred$sampleNameEdit, dfTruth$sampleNameEdit)
  
  dfPredIntersect <- dfPred %>%
    filter(sampleNameEdit %in% c(intersect))
  
  dfTruthIntersect <- dfTruth %>%
    filter(sampleNameEdit %in% c(intersect))

  # Join and compute RMSE
  rmseDf <- dfPredIntersect %>%
    left_join(dfTruthIntersect, 
              by = c("sampleNameEdit", "manual.log.anot.fine")) %>%
    group_by(manual.log.anot.fine, 
             Method_Param) %>%
    summarise(RMSE = sqrt(mean(((cellProportion - truth) * 100)^2)), 
              .groups = "drop")
  
  return(rmseDf)
}

rmseByCellTypeMedian <- function(df, pred_type) {
  
  dfPred <- df %>%
    filter(sampleType %in% c(pred_type)) %>%
    select(sampleNameEdit, 
           sampleName, 
           manual.log.anot.fine, 
           cellProportion, 
           Method_Param)
  
  dfTruth <- df %>%
    filter(sampleType == "sn") %>%
    select(sampleNameEdit, 
           sampleName, 
           manual.log.anot.fine, 
           cellProportion) %>%
    dplyr::rename(truth = cellProportion)
  
  # 7 single-cell samples, 10 bulk cell and 10 bulk nuc samples. 
  intersect <- intersect(dfPred$sampleNameEdit, dfTruth$sampleNameEdit)
  
  dfPredIntersect <- dfPred %>%
    filter(sampleNameEdit %in% c(intersect))
  
  dfTruthIntersect <- dfTruth %>%
    filter(sampleNameEdit %in% c(intersect))

  # Join and compute RMSE
  rmseDf <- dfPredIntersect %>%
    left_join(dfTruthIntersect, 
              by = c("sampleNameEdit", "manual.log.anot.fine")) %>%
    group_by(manual.log.anot.fine, 
             Method_Param) %>%
    summarise(RMSE = sqrt(median(((cellProportion - truth) * 100)^2)), 
              .groups = "drop") 
  
  return(rmseDf)
}

rmseBySampleMean <- function(df, pred_type) {
  
  dfPred <- df %>%
    filter(sampleType %in% c(pred_type)) %>%
    select(sampleNameEdit, 
           sampleName, 
           manual.log.anot.fine, 
           cellProportion, 
           Method_Param)
  
  dfTruth <- df %>%
    filter(sampleType == "sn") %>%
    select(sampleNameEdit, 
           sampleName, 
           manual.log.anot.fine, 
           cellProportion) %>%
    dplyr::rename(truth = cellProportion)
  
  # 7 single-cell samples, 10 bulk cell and 10 bulk nuc samples. 
  intersect <- intersect(dfPred$sampleNameEdit, dfTruth$sampleNameEdit)
  
  dfPredIntersect <- dfPred %>%
    filter(sampleNameEdit %in% c(intersect))
  
  dfTruthIntersect <- dfTruth %>%
    filter(sampleNameEdit %in% c(intersect))

  # Join and compute RMSE
  rmseDf <- dfPredIntersect %>%
    left_join(dfTruthIntersect, 
              by = c("sampleNameEdit", "manual.log.anot.fine")) %>%
    group_by(sampleNameEdit, 
             Method_Param) %>%
    summarise(RMSE = sqrt(mean(((cellProportion - truth) * 100)^2)), 
              .groups = "drop") 
  
  return(rmseDf)
}

rmseBySampleMedian <- function(df, pred_type) {
  
  dfPred <- df %>%
    filter(sampleType %in% c(pred_type)) %>%
    select(sampleNameEdit, 
           sampleName, 
           manual.log.anot.fine, 
           cellProportion, 
           Method_Param)
  
  dfTruth <- df %>%
    filter(sampleType == "sn") %>%
    select(sampleNameEdit, 
           sampleName, 
           manual.log.anot.fine, 
           cellProportion) %>%
    dplyr::rename(truth = cellProportion)
  
  # 7 single-cell samples, 10 bulk cell and 10 bulk nuc samples. 
  intersect <- intersect(dfPred$sampleNameEdit, dfTruth$sampleNameEdit)
  
  dfPredIntersect <- dfPred %>%
    filter(sampleNameEdit %in% c(intersect))
  
  dfTruthIntersect <- dfTruth %>%
    filter(sampleNameEdit %in% c(intersect))

  # Join and compute RMSE
  rmseDf <- dfPredIntersect %>%
    left_join(dfTruthIntersect, 
              by = c("sampleNameEdit", "manual.log.anot.fine")) %>%
    group_by(sampleNameEdit, 
             Method_Param) %>%
    summarise(RMSE = sqrt(median(((cellProportion - truth) * 100)^2)), 
              .groups = "drop") 
  
  return(rmseDf)
}

rmseCombinedCellNucSampleMean <- function(df, pred_type) {
  
  dfPred <- df %>%
    # filter(sampleType %in% c(pred_type)) %>%
    select(sampleNameEdit, 
           sampleName, 
           manual.log.anot.fine, 
           cellProportion, 
           Method_Param) %>%
    mutate(sampleName)
  
  dfTruth <- df %>%
    # filter(sampleType == "sn") %>%
    select(sampleNameEdit, 
           sampleName, 
           manual.log.anot.fine, 
           cellProportion) %>%
    dplyr::rename(truth = cellProportion)
  
  # 7 single-cell samples, 10 bulk cell and 10 bulk nuc samples. 
  intersect <- intersect(dfPred$sampleNameEdit, dfTruth$sampleNameEdit)
  
  dfPredIntersect <- dfPred %>%
    filter(sampleNameEdit %in% c(intersect))
  
  dfTruthIntersect <- dfTruth %>%
    filter(sampleNameEdit %in% c(intersect))

  # Join and compute RMSE
  rmseDf <- dfPredIntersect %>%
    left_join(dfTruthIntersect, 
              by = c("sampleNameEdit", "manual.log.anot.fine")) %>%
    group_by(sampleNameEdit, 
             Method_Param) %>%
    summarise(RMSE = sqrt(mean(((cellProportion - truth) * 100)^2)), 
              .groups = "drop") 
  
  return(rmseDf)
}
```
#### 5.2.2.1 Plot and save results
##### 5.2.2.1.1 By cell type - mean
```{r}
allRmseList <- list()

# Plot
pdf(paste0(plotDir, "/heatmaps/", fprefix, "_meanRmse_byCellType.pdf"), 
      height = 6, width = 6)

for (ptype in c("bn", "bc")) {
    
    name <- ifelse(ptype=="bn", "bulkNuc", "bulkCell")
    rmse <- rmseByCellTypeMean(df = masterPropDf, 
                               pred_type = ptype)
    
    # Cast into matrix for heatmap
    rmseMat <- rmse %>%
      pivot_wider(names_from = Method_Param, 
                  values_from = RMSE) %>%
      column_to_rownames("manual.log.anot.fine") %>%
      as.matrix()
    
    pheatmap(rmseMat,
             main = paste0("RMSE - Matched Samples\n", name),
             color = colorRampPalette(c("white","pink", "red"))(100),
             breaks = seq(0, 100, length.out = 101), 
             angle_col = 45, fontsize_col = 5) 
    
    # Save for export
    allRmseList[[name]] <- rmse
  }

dev.off()
```



##### 5.2.1.1.1 By cell type - median
```{r}
allRmseList <- list()

# Plot
pdf(paste0(plotDir, "/heatmaps/", fprefix, "_medianRmse_byCellType.pdf"), 
      height = 6, width = 6)

for (ptype in c("bn", "bc")) {
    
    name <- ifelse(ptype=="bn", "bulkNuc", "bulkCell")
    rmse <- rmseByCellTypeMedian(df = masterPropDf, 
                               pred_type = ptype)
    
    # Cast into matrix for heatmap
    rmseMat <- rmse %>%
      pivot_wider(names_from = Method_Param, 
                  values_from = RMSE) %>%
      column_to_rownames("manual.log.anot.fine") %>%
      as.matrix()
    
    pheatmap(rmseMat,
             main = paste0("RMSE - Matched Samples\n", name),
             color = colorRampPalette(c("white","pink", "red"))(100),
             breaks = seq(0, 100, length.out = 101), 
             angle_col = 90, fontsize_col = 6) 
    
    # Save for export
    allRmseList[[name]] <- rmse
  }

dev.off()
```

##### 5.2.1.1.1 By sample - mean
```{r}
allRmseList <- list()

# Plot
pdf(paste0(plotDir, "/heatmaps/", fprefix, "_meanRmse_bySampleNameEdit.pdf"), 
      height = 6, width = 6)

for (ptype in c("bn", "bc")) {
    
    name <- ifelse(ptype=="bn", "bulkNuc", "bulkCell")
    rmse <- rmseBySampleMean(df = masterPropDf, 
                               pred_type = ptype)
    
    # Cast into matrix for heatmap
    rmseMat <- rmse %>%
      pivot_wider(names_from = Method_Param, 
                  values_from = RMSE) %>%
      column_to_rownames("sampleNameEdit") %>%
      as.matrix()
    
    pheatmap(rmseMat,
             main = paste0("RMSE - Matched Samples\n", name),
             color = colorRampPalette(c("white","pink", "red"))(100),
             breaks = seq(0, 100, length.out = 101), 
             angle_col = 90, fontsize_col = 6) 
    
    # Save for export
    allRmseList[[name]] <- rmse
  }

dev.off()
```

##### 5.2.1.1.1 By sample - median
```{r}
allRmseList <- list()

# Plot
pdf(paste0(plotDir, "/heatmaps/", fprefix, "_medianRmse_bySampleNameEdit.pdf"), 
      height = 6, width = 6)

for (ptype in c("bn", "bc")) {
    
    name <- ifelse(ptype=="bn", "bulkNuc", "bulkCell")
    rmse <- rmseBySampleMedian(df = masterPropDf, 
                               pred_type = ptype)
    
    # Cast into matrix for heatmap
    rmseMat <- rmse %>%
      pivot_wider(names_from = Method_Param, 
                  values_from = RMSE) %>%
      column_to_rownames("sampleNameEdit") %>%
      as.matrix()
    
    pheatmap(rmseMat,
             main = paste0("RMSE - Matched Samples\n", name),
             color = colorRampPalette(c("white","pink", "red"))(100),
             breaks = seq(0, 100, length.out = 101), 
             angle_col = 90, fontsize_col = 6) 
    
    # Save for export
    allRmseList[[name]] <- rmse
  }

dev.off()
```
##### 5.2.2.1.5 All samples - mean
```{r}
# Compute RMSE using adjusted sample names for with sn matrix. Then left join with original sample names for each result. Then rbind all results and use original sample name as rows in pheatmap. 
rmseNucDf <- masterPropDf %>%
    filter(sampleType %in% c("bn")) %>%
    select(sampleNameEdit, 
           sampleName) %>%
  unique()


rmseNuc <- rmseBySampleMean(masterPropDf, 
                            pred_type = "bn") %>%
  left_join(rmseNucDf) %>%
  select(-sampleNameEdit)
  
rmseCellDf <- masterPropDf %>%
    filter(sampleType %in% c("bc")) %>%
    select(sampleNameEdit, 
           sampleName) %>%
  unique()

rmseCell <- rmseBySampleMean(masterPropDf, pred_type = "bc")%>%
  left_join(rmseCellDf) %>%
  select(-sampleNameEdit)

rmseAllSamples <- rbind(rmseNuc, rmseCell)

   

rmseMat <- rmseAllSamples %>%
      pivot_wider(names_from = Method_Param, 
                  values_from = RMSE) %>%
      column_to_rownames("sampleName") %>%
      as.matrix()


pdf(paste0(plotDir, "/heatmaps/", fprefix, "_meanRmse_bySampleName_allMatchedSamples.pdf"), 
      height = 6, width = 6)
pheatmap(rmseMat,
             main = paste0("RMSE - Matched Samples\n"),
             color = colorRampPalette(c("white","pink", "red"))(100),
             breaks = seq(0, 100, length.out = 101), 
             angle_col = 90, fontsize_col = 6) 
dev.off()
```

##### 5.2.2.1.5 All samples - median
```{r}
# Compute RMSE using adjusted sample names for with sn matrix. Then left join with original sample names for each result. Then rbind all results and use original sample name as rows in pheatmap. 
rmseNucDf <- masterPropDf %>%
    filter(sampleType %in% c("bn")) %>%
    select(sampleNameEdit, 
           sampleName) %>%
  unique()


rmseNuc <- rmseBySampleMedian(masterPropDf, 
                            pred_type = "bn") %>%
  left_join(rmseNucDf) %>%
  select(-sampleNameEdit)
  
rmseCellDf <- masterPropDf %>%
    filter(sampleType %in% c("bc")) %>%
    select(sampleNameEdit, 
           sampleName) %>%
  unique()

rmseCell <- rmseBySampleMedian(masterPropDf, pred_type = "bc")%>%
  left_join(rmseCellDf) %>%
  select(-sampleNameEdit)

rmseAllSamples <- rbind(rmseNuc, rmseCell)

   

rmseMat <- rmseAllSamples %>%
      pivot_wider(names_from = Method_Param, 
                  values_from = RMSE) %>%
      column_to_rownames("sampleName") %>%
      as.matrix()


pdf(paste0(plotDir, "/heatmaps/", fprefix, "_medianRmse_bySampleName_allMatchedSamples_noRange.pdf"), 
      height = 6, width = 6)
pheatmap(rmseMat,
             main = paste0("RMSE - Matched Samples\n"),
             color = colorRampPalette(c("white","pink", "red"))(100),
             breaks = seq(0, 100, length.out = 101), 
             angle_col = 90, fontsize_col = 6) 
dev.off()
```

### 5.2.2 All samples all cell types - 


#### 5.2.2.2 Tile plots (MAE, MAECorr, SCorr, CCorr) - subsampled hvgs only!

##### 5.2.2.2.1 Bulk Nuc
```{r}
# Reshape data to long format
plot_df <- masterMetricDf %>%
  # filter(Reference %in% c("subsampledCellsHvgs", "subSampledCellsHvgs")) %>%
  pivot_longer(cols = c(bulkCellEstimate, bulkNucEstimate), 
               names_to = "EstimateType", values_to = "Value") %>%
  mutate(
    Metric = factor(Metric, levels = c("MAE", "MAECorr", "SCorr", "CCorr")),
    Method_Param = fct_rev(factor(Method_Param_Reference))  # Reverse for y-axis
  )

plot_metric_tile <- function(data, 
                             estimate_type, 
                             metric_name, 
                             fill_low, 
                             fill_high, 
                             title,
                             reverse = FALSE) {
  
  df <- data %>%
    filter(EstimateType == estimate_type, Metric == metric_name)
  
  # Define the color scale limits based on the metric name
  color_limits <- if (metric_name %in% c("SCorr", "CCorr")) {
    c(-1, 1)  # for SCorr or CCorr
  } else {
    c(0, 1)   # for MAE or MAECorr
  }
  
  # Create the plot
  # p <- ggplot(df, aes(x = Metric, y = Method_Param_Reference, fill = Value)) +
  #   geom_tile(color = "white") +
  #   scale_y_discrete(expand = expansion(mult = c(0, 0))) +
  #   scale_x_discrete(
  #   expand = expansion(mult = c(0, 0)),
  #   labels = function(x) str_wrap(x, width = 10)
  # ) +
  #   (if (reverse) 
  #       scale_fill_gradient(low = fill_high, high = fill_low, na.value = "white", limits = color_limits)
  #    else 
  #       scale_fill_gradient(low = fill_low, high = fill_high, na.value = "white", limits = color_limits)) +
  #   theme_minimal(base_size = 14) +
  #   labs(x = NULL, y = NULL, fill = metric_name) +
  #   ggtitle(title) +
  #   theme(
  #     axis.text.x = element_blank(),
  #     axis.ticks.x = element_blank(),
  #     strip.text = element_text(size = 14),
  #     plot.title = element_text(hjust = 0.5),
  #     legend.title = element_blank(),
  #     axis.text.y = element_text(angle = 45, size = 8, hjust = 1)  # Rotate y-axis labels
  #   )
  
  # With text 
  p <- ggplot(df, aes(x = Metric, y = Method_Param_Reference, fill = Value)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(Value, 2)), size = 3) +  # <-- Add this line
  scale_y_discrete(expand = expansion(mult = c(0, 0))) +
  scale_x_discrete(
    expand = expansion(mult = c(0, 0)),
    labels = function(x) str_wrap(x, width = 10)
  ) +
  (if (reverse) 
      scale_fill_gradient(low = fill_high, high = fill_low, na.value = "white", limits = color_limits)
   else 
      scale_fill_gradient(low = fill_low, high = fill_high, na.value = "white", limits = color_limits)) +
  theme_minimal(base_size = 14) +
  labs(x = NULL, y = NULL, fill = metric_name) +
  ggtitle(title) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.text = element_text(size = 14),
    plot.title = element_text(hjust = 0.5),
    legend.title = element_blank(),
    axis.text.y = element_text(angle = 45, size = 8, hjust = 1)
  )

  
  return(p)
}



# Bulk Nucleus Plots
p1_nuc <- plot_metric_tile(plot_df, 
                           "bulkNucEstimate", 
                           "MAE", 
                           fill_low = "firebrick3", 
                           fill_high = "lightyellow", 
                           title = "Nuc",
                           reverse = T) # Lower MAE is better. 
p2_nuc <- plot_metric_tile(plot_df, 
                           "bulkNucEstimate", 
                           "MAECorr", 
                           "navyblue", 
                           "lightblue", 
                           title = "Nuc",
                           reverse = T) # Lower MAECorr is better. 
p3_nuc <- plot_metric_tile(plot_df, 
                           "bulkNucEstimate", 
                           "SCorr", 
                           "deeppink", 
                           "mistyrose",
                           title = "Nuc",
                           reverse = F) # Higher Corr is better
p4_nuc <- plot_metric_tile(plot_df, 
                           "bulkNucEstimate", 
                           "CCorr", 
                           
                           "darkgreen", 
                           "palegreen", 
                           title = "Nuc",
                           reverse = F)# Higher Corr is better

# Combine into one row
# nucleus_plot <- p1_nuc + p2_nuc + p3_nuc + p4_nuc + plot_layout(ncol = 4) +
#   plot_annotation(title = "Metric Heatmap for Bulk Nucleus Estimates")
 
# bulknucMetricsPerMethodParam <- wrap_plots(p1_nuc,
#                    p2_nuc,
#                    p3_nuc,
#                    p4_nuc,
#                    ncol=4,
#                    axis_titles="collect",
#                    axes="collect") +
#   plot_layout(guides = "collect") &
#   theme(legend.position = "bottom") 
# 
# 
# ggsave(paste0(plotDir, 
#               "tile/", 
#               fprefix, "_bulkNucMetricsPerMethodParam.pdf"), 
#        bulknucMetricsPerMethodParam,
#        height = 5, 
#        width= 10)
```
##### 5.2.2.2.2 Bulk Cell
```{r}
# Bulk Cellleus Plots
p1_cell <- plot_metric_tile(plot_df, 
                            "bulkCellEstimate", 
                            "MAE", 
                            "firebrick3", 
                            "lightyellow", 
                            title = "Cell",
                            reverse = T)
p2_cell <- plot_metric_tile(plot_df, 
                            "bulkCellEstimate", 
                            "MAECorr", 
                            "navyblue", 
                            "lightblue", 
                            title = "Cell",
                            reverse = T)
p3_cell <- plot_metric_tile(plot_df, 
                            "bulkCellEstimate", 
                            "SCorr", 
                            "deeppink", 
                            "mistyrose",
                            title = "Cell",
                            reverse = F)
p4_cell <- plot_metric_tile(plot_df, 
                            "bulkCellEstimate", 
                            "CCorr", 
                            "darkgreen", 
                            "palegreen", 
                            title = "Cell",
                            reverse = F)

# Combine into one row
# cellleus_plot <- p1_cell + p2_cell + p3_cell + p4_cell + plot_layout(ncol = 4) +
#   plot_annotation(title = "Metric Heatmap for Bulk Cellleus Estimates")
 
# bulkcellMetricsPerMethodParam <- wrap_plots(p1_cell,
#                    p2_cell,
#                    p3_cell,
#                    p4_cell,
#                    ncol=4,
#                    axis_titles="collect",
#                    axes="collect") +
#   plot_layout(guides = "collect") &
#   theme(legend.position = "bottom") &
#   theme(
#     legend.text = element_text(size = 8),        
#     legend.title = element_text(size = 9)         
#   ) +
#   theme(
#   axis.text.x = element_blank(),
#   axis.ticks.x = element_blank(),
#   strip.text = element_text(size = 14),
#   plot.title = element_text(hjust = 0.5),
#   legend.title = element_blank(),
#   axis.text.y = element_text(angle = 45, 
#                              size = 10, 
#                              hjust = 1) 
# )
# 
# 
# ggsave(paste0(plotDir, 
#               "tile/", 
#               fprefix, "_bulkCellMetricsPerMethodParam.pdf"), 
#        bulkcellMetricsPerMethodParam,
#        height = 5, 
#        width= 10)
```
##### 5.2.2.2.2 Bulk Nuc and Cell (Nuc Cell Nuc Cell)

```{r}
# # Combine side-by-side
# combinedPlot <- wrap_plots(
#   bulknucMetricsPerMethodParam, 
#   bulkcellMetricsPerMethodParam, nrow=2) +
#   plot_layout(guides = "collect") &
#   theme(legend.position = "bottom")

(bulknuccellMetricsPerMethodParam <- wrap_plots(p1_nuc,
                                            p1_cell,
                                            p2_nuc,
                                            p2_cell,
                                            p3_nuc,
                                            p3_cell,
                                            p4_nuc,
                                            p4_cell,
                                            ncol=8,
                                            nrow=1,
                                            axis_titles="collect",
                                            axes="collect") +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom") &
  theme(
    legend.text = element_text(size = 8),        
    legend.title = element_text(size = 9)         
  ) +
  theme(
  axis.text.x = element_blank(),
  axis.ticks.x = element_blank(),
  strip.text = element_text(size = 14),
  plot.title = element_text(hjust = 0.5),
  # legend.title = element_blank(),
  axis.text.y = element_text(angle = 45, 
                             size = 10, 
                             hjust = 1) 
))

ggsave(paste0(plotDir, 
              "tile/", 
              fprefix, "_bulkNucCellMetricsPerMethodParam_long.pdf"), 
       bulknuccellMetricsPerMethodParam,
       height = 10, 
       width= 12)
```

# ---- Version 2: LOO Models ----
Comparing a full reference (all cells, all features) with a LOO approach. 
Question: How sensitive are methods to reference samples, and how does this vary per deconvolution method?

# 0 Environment
## 0.2 Paths
```{r echo=F, message=FALSE, warning=FALSE}
wDir <- paste0("~/Desktop/1_Deconvolution/")
dataDir <- paste0(wDir, "/11_Data/")
bulkDir <- paste0(wDir, "For_Nina/01_RNAseq_analysis/01_CTVT/Data_input_htseq_reverse/")
scriptDir <- paste0(wDir, "12_Scripts/")

fprefix <- "01_Deconvolution_bayesPrismLOO"
# dir.create(paste0(resDir, fprefix))
resDir <- paste0(wDir, "/13_Results/", fprefix, "/")
plotDir <- paste0(wDir, "/14_Plots/", fprefix, "/")

# Will need to clean this up later -- for now the LOO objects are in the scaden results file because its easier to run from the same directory. 
resDirScadenLoo <- paste0(wDir, "/13_Results/01_Deconvolution_scadenLOO/0_scadenInput/")

```
# 1.0 Inputs
BayesPrism will take intersect of genes in reference and bulk samples.
Use unnormalized and untransformed count data.

## 1.1 Reference
Reference - cellxgene dense matrix.
### 1.1.1 Full object
#### 1.1.1.1 Read in counts matrix
```{r}
snCountsFinal <- readRDS(paste0(dataDir, "01_Deconvolution_geneAnnotationsCTVTRef_snCountsFinal.rds"))
```

#### 1.1.1.2 Cell type annotations
Cell type labels - character vector same length as # cells in reference.
Cell state labels - optional, finer granularity character vector. (i.e. myeloid 1 vs myeloid 2). 
Labels should have at least 20 to 50 cells. 
```{r}
snCountsFinal_colData <- read.xlsx(paste0(dataDir, "01_Deconvolution_geneAnnotationsCTVTRefsnCountsFinal_colData.xlsx"))

# Check rownames were preserved
head(snCountsFinal_colData$colDataRowName)

snAnno <- snCountsFinal_colData$manual.log.anot.fine
print(ncol(snCountsFinal)==length(snAnno))
print(sort(table(snAnno)))

# Create the cell count matrix: rows = cell types, columns = samples
snCellCounts <- snCountsFinal_colData %>%
  group_by(manual.log.anot.fine, 
           Sample) %>%
  summarise(cellCount = n()) %>%
  pivot_wider(names_from = Sample, 
              values_from = cellCount, 
              values_fill = 0) %>%
  column_to_rownames("manual.log.anot.fine")

# Convert to percentages (column-wise normalization)
snCellPercentages <- sweep(snCellCounts, 
                           2, 
                           colSums(snCellCounts), 
                           FUN = "/") %>%
  round(3) %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(
    cols = -sample,
    names_to = "manual.log.anot.fine",
    values_to = "cellProportion"
  ) %>%
  # If sample name ends in b_n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
  mutate(
    sampleType = "sn",
    sampleName = sample, 
    sampleNameEdit = str_remove(sampleName, "[ab]")
  ) %>%
  select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
  mutate("deconvBenchResType" = "groundTruth", # P for proportion
         "Method" = "NA", 
         "Parameters" = "NA", 
         "Reference" = "snCounts",
         "Seed"=123)

```

### 1.1.2 LOO Objects
```{r}
# List all .h5ad files with full paths
looObjs <- list.files(path = paste0(resDirScadenLoo), 
                      pattern = "\\.h5ad$", 
                      full.names = TRUE)
```


## 1.3 Bulk
### 1.2.1 Matrix
```{r}
bulkCountsFinal <- readRDS(paste0(dataDir, "01_Deconvolution_matchedBulkMatrixCTVT_bulkCountsFinal.rds"))
```
### 1.3.2 Metadata
```{r}
bulkCountsFinal_metadata <- read.xlsx(paste0(dataDir, "01_Deconvolution_matchedBulkMatrixCTVTf_bulkCountsFinal_metadata.xlsx"))
```
## 1.4 Create masterDf's
```{r}
masterPropDf <- data.frame(sampleName = c(), 
                           sampleType = c(), 
                           manual.log.anot.fine = c(), 
                           cellProportion =c(), 
                           sampleNameEdit = c(), 
                           deconvBenchResType = c(), 
                           Method = c(), 
                           Parameters = c())


masterGlobMetricDf <- data.frame(bulkCellEstimate = c(), 
                             bulkNucEstimate = c(), 
                             Method = c(), 
                             Parameters = c(), 
                             Metric = c(), 
                             Reference = c())

masterGranularMetricDf <- data.frame(
  Metric = c(), 
  Value = c(),
  Comparison=c(),
  Subject = c(),
  Estimate = c(),
  Method = c(), 
  Parameters = c(),
  Seed = c(), 
  Reference = c()
)

source(paste0(scriptDir, "01_Deconvolution_deconBenchmark_metricFunctions.R"))
```

## 1.4 Full object
### 1.4.1 Construct prism
```{r}
myPrism <- new.prism(
  reference = snCountsFinal %>% t(), 
  mixture = bulkCountsFinal %>% t(), 
  cell.type.labels = snAnno, 
  cell.state.labels = snAnno,
  key = NULL, 
  outlier.cut = 0.01, # Filter genes in the bulk sample with an expression fraction greater than 1% in more than 10% of bulk data. These genes may dominate as outliers resulting from less stringent QC after mapping. 
  outlier.fraction = 0.1
)

bpRes <- run.prism(prism = myPrism, 
                       n.cores=8)
```

### 1.4.2 Results
#### 1.4.2.1 Theta first (pre-batch correction)
```{r}
# extract posterior mean of cell type fraction theta
theta <- get.fraction (bp=bpRes,
            which.theta="first", # Pre Gibbs
            state.or.type="type")

head(theta)

# Pivot to long format
bayesPrismRes <- theta %>%
   as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(
    cols = -sample,
    names_to = "manual.log.anot.fine",
    values_to = "cellProportion"
  ) %>%
  # If sample name ends in _n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
  mutate(
    sampleType = case_when(
      str_ends(sample, "_n") ~ "bn",
      TRUE ~ "bc"
    ),
    # If sample type is bn, remove b_n to save sample id only. 
    sampleName = case_when(
      sampleType == "bn" ~ str_remove(sample, "_n$"),
      TRUE ~ sample
    ), 
    # If sample type is bn, remove a or b from the end of the sample name. 
    sampleNameEdit = case_when(
      sampleType == "bn" ~ str_remove(sampleName, "[ab]"),
      TRUE ~ sampleName
    ),
  ) %>%
  select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
  # Method details
  mutate("deconvBenchResType" = "P", # P for proportion
         "Method" = "BayesPrism", 
         "Parameters" = "thetaFirst",
         "Reference" = "snCounts",
         "Seed"=123)

# Rbind proportion outputs to compute error metrics.
bayesResGround <- rbind(bayesPrismRes,
                        snCellPercentages)

# Only time I save resGround instead of bayesPrismRes. So that the ground truth percentages will be saved only 1 time instead of everytime we rbind with masterPropDf. 
masterPropDf <- rbind(masterPropDf,
                      bayesResGround)

# Compute and rbind metric outputs
bayesResMetrics <- deconError(bayesResGround, 
                              parameters = "thetaFirst",
                              method = "BayesPrism",
                              reference="snCounts",
                              seed=123)
# Rbind metric measurements 
masterGlobMetricDf <- rbind(masterGlobMetricDf, 
                        bayesResMetrics$overviewMetrics)

masterGranularMetricDf <- rbind(masterGranularMetricDf, 
                        bayesResMetrics$granularMetrics)

# Cleanup
rm(snCountsRes, 
   bayesResGround, 
   bayesResMetrics, 
   theta)

gc()

dim(reducedDim(temp, "TSNE_corrected"))

celltype_colors <- c(
  "CTVT_cells" = "forestgreen",
  "CAFs" = "cornflowerblue",
  "Endothelial_cells" = "orange1",
  "T_cells" = "lightpink",
  "Plasma_cells" = "firebrick",
  "Mono.Macro.DC" = "plum"  # "lilac" isn't a base R color; "plum" is a close alternative
)

pdf("~/test.pdf", height = 5, width = 7)
print(# Increase font size of legend labels and title
p +
  scale_color_manual(values = celltype_colors) +
  guides(colour = guide_legend(override.aes = list(size = 5))) +  # Bigger legend dots
  theme(
    legend.text = element_text(size = 12),
    legend.title = element_text(size = 14)
  ))
dev.off()
```

#### 1.4.2.2 Theta final (post-batch correction)
```{r}
# extract posterior mean of cell type fraction theta
theta <- get.fraction (bp=bpRes,
            which.theta="final", # Pre Gibbs
            state.or.type="type")

head(theta)

# Pivot to long format
bayesPrismRes <- theta %>%
   as.data.frame() %>%
  rownames_to_column("sample") %>%
  pivot_longer(
    cols = -sample,
    names_to = "manual.log.anot.fine",
    values_to = "cellProportion"
  ) %>%
  # If sample name ends in _n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
  mutate(
    sampleType = case_when(
      str_ends(sample, "_n") ~ "bn",
      TRUE ~ "bc"
    ),
    # If sample type is bn, remove b_n to save sample id only. 
    sampleName = case_when(
      sampleType == "bn" ~ str_remove(sample, "_n$"),
      TRUE ~ sample
    ), 
    # If sample type is bn, remove a or b from the end of the sample name. 
    sampleNameEdit = case_when(
      sampleType == "bn" ~ str_remove(sampleName, "[ab]"),
      TRUE ~ sampleName
    ),
  ) %>%
  select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
  # Method details
  mutate("deconvBenchResType" = "P", # P for proportion
         "Method" = "BayesPrism", 
         "Parameters" = "thetaFinal",
         "Reference" = "snCounts",
         "Seed"=123)

# Rbind proportion outputs to compute error metrics.
bayesResGround <- rbind(bayesPrismRes,
                        snCellPercentages)

masterPropDf <- rbind(masterPropDf,
                      bayesPrismRes)

# Compute and rbind metric outputs
bayesResMetrics <- deconError(bayesResGround, 
                              parameters = "thetaFinal",
                              method = "BayesPrism",
                              reference="snCounts",
                              seed=123)
# Rbind metric measurements 
masterGlobMetricDf <- rbind(masterGlobMetricDf, 
                        bayesResMetrics$overviewMetrics)

masterGranularMetricDf <- rbind(masterGranularMetricDf, 
                        bayesResMetrics$granularMetrics)

# Cleanup
rm(snCountsRes, 
   bayesResGround, 
   bayesResMetrics, 
   theta,
   snCountsFinal)

gc()
```




## 1.5 Loop through LOO
```{r}
obj <- readRDS(paste0(dataDir,
                      "/01_Deconvolution_geneAnnotationsCTVTRef_updatedObj.rds"))

samples <- unique(obj$Sample)

for (samp in samples){
  ##############
  # 0.0 Metadata 
  ##############
  
  temp <- obj[, obj$Sample != samp]
  
  name <- paste0("LOO_", samp)
  
  print(name)
  
  snAnnoFinalTemp <- colData(temp)$manual.log.anot.fine
  
  snColDataTemp <- colData(temp)
  
  # We don't need new cell percentages because all samples were still included in bulk, only excluded from the reference. 
  
  # snCellPercentagesTemp <- snCellPercentages %>%
  #   filter(!sampleName %in% samp) %>%
  #   mutate(Reference = name)
  
  temp <- temp@assays@data$counts 
  
  #####################
  # 1.0 Run bayes prism
  #####################
  
  myPrism <- new.prism(
    reference = temp %>% t(), 
    mixture = bulkCountsFinal %>% t(), 
    cell.type.labels = snAnnoFinalTemp, 
    cell.state.labels = snAnnoFinalTemp,
    key = NULL, 
    outlier.cut = 0.01, # Filter genes in the bulk sample with an expression fraction greater than 1% in more than 10% of bulk data. These genes may dominate as outliers resulting from less stringent QC after mapping. 
    outlier.fraction = 0.1
  )
  
  rm(temp)
  gc()

  bpRes <- run.prism(prism = myPrism, 
                         n.cores=8)
  
  rm(myPrism) 
  gc()
  
  #################
  # 2.0 Theta first
  #################
  # extract posterior mean of cell type fraction theta
  theta <- get.fraction (bp=bpRes,
              which.theta="first", # Pre Gibbs
              state.or.type="type")
  
  head(theta)
  
  # Pivot to long format
  bayesPrismRes <- theta %>%
     as.data.frame() %>%
    rownames_to_column("sample") %>%
    pivot_longer(
      cols = -sample,
      names_to = "manual.log.anot.fine",
      values_to = "cellProportion"
    ) %>%
    # If sample name ends in _n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
    mutate(
      sampleType = case_when(
        str_ends(sample, "_n") ~ "bn",
        TRUE ~ "bc"
      ),
      # If sample type is bn, remove b_n to save sample id only. 
      sampleName = case_when(
        sampleType == "bn" ~ str_remove(sample, "_n$"),
        TRUE ~ sample
      ), 
      # If sample type is bn, remove a or b from the end of the sample name. 
      sampleNameEdit = case_when(
        sampleType == "bn" ~ str_remove(sampleName, "[ab]"),
        TRUE ~ sampleName
      ),
    ) %>%
    select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
    # Method details
    mutate("deconvBenchResType" = "P", # P for proportion
           "Method" = "BayesPrism", 
           "Parameters" = "thetaFirst",
           "Reference" = name,
           "Seed"=123)
  
  # Rbind proportion outputs to compute error metrics.
  bayesResGround <- rbind(bayesPrismRes,
                          snCellPercentages)
  
  # Saving with ground truth percentages (only for the first BP result, otherwise will be repeated each time.)
  
  masterPropDf <- rbind(masterPropDf,
                        bayesPrismRes)
  
  # Compute and rbind metric outputs
  bayesResMetrics <- deconError(bayesResGround, 
                                parameters = "thetaFirst",
                                method = "BayesPrism",
                                reference=name,
                                seed=123)
  # Rbind metric measurements 
  masterGlobMetricDf <- rbind(masterGlobMetricDf, 
                          bayesResMetrics$overviewMetrics)
  
  masterGranularMetricDf <- rbind(masterGranularMetricDf, 
                          bayesResMetrics$granularMetrics)
  
  # Cleanup
  rm(bayesPrismRes,
     bayesResGround, 
     bayesResMetrics, 
     theta)
  
  gc()
  
  #################
  # 3.0 Theta final
  #################
  # extract posterior mean of cell type fraction theta
  theta <- get.fraction (bp=bpRes,
              which.theta="final", # Pre Gibbs
              state.or.type="type")
  
  head(theta)
  
  # Pivot to long format
  bayesPrismRes <- theta %>%
     as.data.frame() %>%
    rownames_to_column("sample") %>%
    pivot_longer(
      cols = -sample,
      names_to = "manual.log.anot.fine",
      values_to = "cellProportion"
    ) %>%
    # If sample name ends in _n, type is bn (bulk nuc). Otherwise, it is bc (bulk cell)
    mutate(
      sampleType = case_when(
        str_ends(sample, "_n") ~ "bn",
        TRUE ~ "bc"
      ),
      # If sample type is bn, remove b_n to save sample id only. 
      sampleName = case_when(
        sampleType == "bn" ~ str_remove(sample, "_n$"),
        TRUE ~ sample
      ), 
      # If sample type is bn, remove a or b from the end of the sample name. 
      sampleNameEdit = case_when(
        sampleType == "bn" ~ str_remove(sampleName, "[ab]"),
        TRUE ~ sampleName
      ),
    ) %>%
    select(sampleName, sampleType, manual.log.anot.fine, cellProportion, sampleNameEdit) %>%
    # Method details
    mutate("deconvBenchResType" = "P", # P for proportion
           "Method" = "BayesPrism", 
           "Parameters" = "thetaFinal",
           "Reference" = name,
           "Seed"=123)
  
  # Rbind proportion outputs to compute error metrics.
  bayesResGround <- rbind(bayesPrismRes,
                          snCellPercentages)
  
  masterPropDf <- rbind(masterPropDf,
                        bayesPrismRes)
  
  # Compute and rbind metric outputs
  bayesResMetrics <- deconError(bayesResGround, 
                                parameters = "thetaFinal",
                                method = "BayesPrism",
                                reference=name,
                                seed=123)
  # Rbind metric measurements 
  masterGlobMetricDf <- rbind(masterGlobMetricDf,
                              bayesResMetrics$overviewMetrics)
  
  masterGranularMetricDf <- rbind(masterGranularMetricDf, 
                                  bayesResMetrics$granularMetrics)
  
  # Cleanup
  rm(bayesPrismRes, 
     bayesResGround, 
     bayesResMetrics, 
     theta)
  
  gc()
  
  # # Keep saving results, in case it breaks. 
  # 
  # write.xlsx(masterPropDf, paste0(resDir, fprefix, "_masterProportionDf.xlsx"))
  # write.xlsx(masterMetricDf, paste0(resDir, fprefix, "_masterMetricDf.xlsx"))
}
```

## 1.6 Save results
```{r}
# write.xlsx(masterPropDf, paste0(resDir, fprefix, "_masterProportionDf.xlsx"))
# write.xlsx(masterGlobMetricDf, paste0(resDir, fprefix, "_masterGlobalMetricDf.xlsx"))
# write.xlsx(masterGranularMetricDf, paste0(resDir, fprefix, "_masterGranularMetricDf.xlsx"))
```

# 2 Visualizations
```{r}
source(paste0(scriptDir, "/01_Deconvolution_deconBenchmark_visualizationFunctions.R"))

manualColors <- c(
  "CAFs"              = "skyblue",  # Red
  "CTVT_cells"        = "#E41A1C",  # Blue
  "Endothelial_cells" = "forestgreen",  # Green
  "Mono.Macro.DC"     = "magenta",  # Purple
  "Plasma_cells"      = "orange",  # Orange
  "T_cells"           = "darkgrey"   # Brown
)
```

## 2.1 Read in results
Run table(df$Method_Param_Reference) to make sure results have looped correctly. 
```{r}
masterGlobMetricDf <- read.xlsx(paste0(resDir, fprefix, "_masterGlobalMetricDf.xlsx")) %>%
  mutate("Method_Param"=paste0(Method, "_", Parameters),
         "Method_Param_Reference" = paste0(Method_Param, "_", Reference))
# table(masterGlobMetricDf$Method_Param_Reference)

masterGranularMetricDf <- read.xlsx(paste0(resDir, fprefix, "_masterGranularMetricDf.xlsx")) %>%
  mutate("Method_Param"=paste0(Method, "_", Parameters),
         "Method_Param_Reference" = paste0(Method_Param, "_", Reference))
# table(masterGranularMetricDf$Method_Param_Reference)


masterPropDf <- read.xlsx(paste0(resDir, fprefix, "_masterProportionDf.xlsx")) %>%
  mutate("Method_Param"=paste0(Method, "_", Parameters),
         "Method_Param_Reference" = paste0(Method_Param, "_", Reference)) %>%
  distinct()
# table(masterPropDf$Method_Param_Reference)

# masterPropDfCheck <- masterPropDf %>%
#   filter(Method_Param_Reference %in% "NA_NA_snCounts")
```

## 2.2 Global metrics
### 2.2.1 Tileplots
#### 2.2.1.1 Dataframe
```{r}
# Reshape data to long format
plot_df <- masterGlobMetricDf %>%
  # filter(Reference %in% c("subsampledCellsHvgs", "subSampledCellsHvgs")) %>%
  pivot_longer(cols = c(bulkCellEstimate, bulkNucEstimate), 
               names_to = "EstimateType", values_to = "Value") %>%
  mutate(
    Metric = factor(Metric, levels = c("MAE", "MAECorr", "SCorr", "CCorr")),
    Method_Param = fct_rev(factor(Method_Param_Reference))  # Reverse for y-axis
  )
```

#### 3.8.2.2 Bulk nuclei
```{r}
# Bulk Nucleus Plots
p1_nuc <- plot_metric_tile(plot_df, 
                           "bulkNucEstimate", 
                           "MAE", 
                           fill_low = "firebrick3", 
                           fill_high = "lightyellow", 
                           title = "Nuc",
                           reverse = T) # Lower MAE is better. 
p2_nuc <- plot_metric_tile(plot_df, 
                           "bulkNucEstimate", 
                           "MAECorr", 
                           "navyblue", 
                           "lightblue", 
                           title = "Nuc",
                           reverse = T) # Lower MAECorr is better. 
p3_nuc <- plot_metric_tile(plot_df, 
                           "bulkNucEstimate", 
                           "SCorr", 
                           "deeppink", 
                           "mistyrose",
                           title = "Nuc",
                           reverse = F) # Higher Corr is better
p4_nuc <- plot_metric_tile(plot_df, 
                           "bulkNucEstimate", 
                           "CCorr", 
                           
                           "darkgreen", 
                           "palegreen", 
                           title = "Nuc",
                           reverse = F)# Higher Corr is better
```

#### 3.8.2.3 Bulk cell
```{r}
# Bulk Cellleus Plots
p1_cell <- plot_metric_tile(plot_df, 
                            "bulkCellEstimate", 
                            "MAE", 
                            "firebrick3", 
                            "lightyellow", 
                            title = "Cell",
                            reverse = T)
p2_cell <- plot_metric_tile(plot_df, 
                            "bulkCellEstimate", 
                            "MAECorr", 
                            "navyblue", 
                            "lightblue", 
                            title = "Cell",
                            reverse = T)
p3_cell <- plot_metric_tile(plot_df, 
                            "bulkCellEstimate", 
                            "SCorr", 
                            "deeppink", 
                            "mistyrose",
                            title = "Cell",
                            reverse = F)
p4_cell <- plot_metric_tile(plot_df, 
                            "bulkCellEstimate", 
                            "CCorr", 
                            "darkgreen", 
                            "palegreen", 
                            title = "Cell",
                            reverse = F)
```
#### 3.8.2.4 Save
```{r}
(bulknuccellMetricsPerMethodParam <- wrap_plots(p1_nuc,
                                            p1_cell,
                                            p2_nuc,
                                            p2_cell,
                                            p3_nuc,
                                            p3_cell,
                                            p4_nuc,
                                            p4_cell,
                                            ncol=8,
                                            nrow=1,
                                            axis_titles="collect",
                                            axes="collect") +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom") &
  theme(
    legend.text = element_text(size = 8),        
    legend.title = element_text(size = 9)         
  ) +
  theme(
  axis.text.x = element_blank(),
  axis.ticks.x = element_blank(),
  strip.text = element_text(size = 14),
  plot.title = element_text(hjust = 0.5),
  # legend.title = element_blank(),
  axis.text.y = element_text(angle = 45, 
                             size = 10, 
                             hjust = 1) 
))

ggsave(paste0(plotDir, 
              "tile/", 
              fprefix, "_bulkNucCellMetricsPerMethodParam_long.pdf"), 
       bulknuccellMetricsPerMethodParam,
       height = 10, 
       width= 12)
```
### 3.8.3 RMSE Heatmaps
#### 3.8.3.1 By cell type - median
```{r}
# Plot
pdf(paste0(plotDir, "/heatmaps/", fprefix, "_medianRmse_byCellType.pdf"), 
      height = 6, width = 14)

for (ptype in c("bn", "bc")) {
    
    name <- ifelse(ptype=="bn", "bulkNuc", "bulkCell")
    rmse <- rmseByCellTypeMedian(df = masterPropDf, 
                               pred_type = ptype)
    
    # Cast into matrix for heatmap
    rmseMat <- rmse %>%
      pivot_wider(names_from = Method_Param_Reference, 
                  values_from = RMSE) %>%
      column_to_rownames("manual.log.anot.fine") %>%
      as.matrix()
    
    print(pheatmap(rmseMat,
             main = paste0("RMSE - Matched Samples\n", name),
             color = colorRampPalette(c("white","pink", "red"))(100),
             breaks = seq(0, 100, length.out = 101), 
             angle_col = "90", fontsize_col = 6, display_numbers = T) )
    
    # Save for export
    # allRmseList[[name]] <- rmse
  }

dev.off()
```

#### 3.8.3.2 By sample - median
```{r}
# allRmseList <- list()

# Plot
pdf(paste0(plotDir, "/heatmaps/", fprefix, "_medianRmse_bySampleNameEdit.pdf"), 
      height = 6, width = 14)

for (ptype in c("bn", "bc")) {
    
    name <- ifelse(ptype=="bn", "bulkNuc", "bulkCell")
    rmse <- rmseBySampleMedian(df = masterPropDf, 
                               pred_type = ptype)
    
    # Cast into matrix for heatmap
    rmseMat <- rmse %>%
      pivot_wider(names_from = Method_Param_Reference, 
                  values_from = RMSE) %>%
      column_to_rownames("sampleNameEdit") %>%
      as.matrix()
    
    print(pheatmap(rmseMat,
             main = paste0("RMSE - Matched Samples\n", name),
             color = colorRampPalette(c("white","pink", "red"))(100),
             breaks = seq(0, 100, length.out = 101), 
             angle_col = "90", fontsize_col = 6, display_numbers = T) )
    
    # Save for export
    # allRmseList[[name]] <- rmse
  }

dev.off()
```
#### 5.2.2.1.5 All samples - median
```{r}
# Compute RMSE using adjusted sample names for with sn matrix. Then left join with original sample names for each result. Then rbind all results and use original sample name as rows in pheatmap. 
rmseNucDf <- masterPropDf %>%
    filter(sampleType %in% c("bn")) %>%
    select(sampleNameEdit, 
           sampleName) %>%
  unique()


rmseNuc <- rmseBySampleMedian(masterPropDf, 
                            pred_type = "bn") %>%
  left_join(rmseNucDf) %>%
  select(-sampleNameEdit)
  
rmseCellDf <- masterPropDf %>%
    filter(sampleType %in% c("bc")) %>%
    select(sampleNameEdit, 
           sampleName) %>%
  unique()

rmseCell <- rmseBySampleMedian(masterPropDf, pred_type = "bc")%>%
  left_join(rmseCellDf) %>%
  select(-sampleNameEdit)

rmseAllSamples <- rbind(rmseNuc, rmseCell)

rmseMat <- rmseAllSamples %>%
      pivot_wider(names_from = Method_Param_Reference, 
                  values_from = RMSE) %>%
      column_to_rownames("sampleName") %>%
      as.matrix()


pdf(paste0(plotDir, "/heatmaps/", fprefix, "_medianRmse_bySampleName_allMatchedSamples_noRange.pdf"), 
      height = 6, width = 14)
pheatmap(rmseMat,
             main = paste0("RMSE - Matched Samples\n"),
             color = colorRampPalette(c("white","pink", "red"))(100),
             breaks = seq(0, 100, length.out = 101), 
             angle_col = "90", fontsize_col = 6, display_numbers = T) 
dev.off()


```
#### 5.2.2.1.5 All samples with CTVT proportion. 
```{r}
rmseRefDf <- masterPropDf %>%
    filter(sampleType %in% c("sn")) %>%
  filter(manual.log.anot.fine %in% c("CTVT_cells")) %>%
    select(
           sampleName, 
           cellProportion) %>%
  unique()

annot_df <- rmseRefDf %>%
  filter(sampleName %in% rownames(rmseMat)) %>%
  column_to_rownames("sampleName") %>%
  dplyr::rename("CTVT_snProportion"="cellProportion")

# Reorder to match matrix rows
annot_df <- annot_df[rownames(rmseMat), , drop = FALSE]


# Define min, median, and max RMSE values
rmse_range <- range(rmseMat, na.rm = TRUE)
rmse_mid <- median(rmseMat, na.rm = TRUE)

# Define color function correctly
rmse_col_fun <- colorRamp2(
  c(rmse_range[1], rmse_mid, rmse_range[2]),
  c("white", "pink", "red"))

# Create the row annotation with a continuous color scale
row_ha <- rowAnnotation(
  CTVT_proportion = annot_df$CTVT_snProportion,
  col = list(CTVT_proportion = colorRamp2(
    range(annot_df$CTVT_snProportion, na.rm = TRUE),
    c("white", "purple")
  )),
  annotation_name_side = "top"
)

ht <- Heatmap(
  rmseMat,
  name = "Median RMSE",
  col = rmse_col_fun,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  row_names_gp = gpar(fontsize = 8),
  column_names_gp = gpar(fontsize = 8),
  left_annotation = row_ha,
  heatmap_legend_param = list(title = "RMSE"),
  ,
  cell_fun = function(j, i, x, y, width, height, fill){
    grid.text(sprintf("%.1f", rmseMat[i, j]), x, y, gp = gpar(fontsize = 6))}
)


pdf(paste0(plotDir, "/heatmaps/", fprefix, "_medianRmse_bySampleName_allMatchedSamples_noRange_withCTVTProp.pdf"), 
      height = 8, width = 16)

print(ht)

dev.off()
```

#### 5.2.2.1.6 All samples with all proportions. 
```{r}
library(ComplexHeatmap)
library(circlize)
library(dplyr)
library(tidyr)

# Step 1: Calculate proportions of all cell types
all_celltype_props <- masterPropDf %>%
  filter(sampleType %in% c("sn")) %>%
  select(sampleName, manual.log.anot.fine, cellProportion) %>%
  unique() %>%
  pivot_wider(
    names_from = manual.log.anot.fine,
    values_from = cellProportion,
    values_fill = 0  # fill missing with 0
  ) %>% 
  select(-"CTVT_cells")

# Step 2: Match row order of rmseMat
all_celltype_props <- all_celltype_props %>%
  filter(sampleName %in% rownames(rmseMat)) %>%
  column_to_rownames("sampleName")

# Reorder to match matrix rows
all_celltype_props <- all_celltype_props[rownames(rmseMat), , drop = FALSE]

# Step 3: Create color scales for each cell type
celltype_colors <- lapply(all_celltype_props, function(x) {
  colorRamp2(
    range(x, na.rm = TRUE),
    c("white", scales::hue_pal()(1))  # assign different color per column later
  )
})

# Assign unique colors to each cell type (using hue palette), except CTVT
celltype_names <- colnames(all_celltype_props)[colnames(all_celltype_props)!="CTVT_cells"]

hues <- scales::hue_pal()(length(celltype_names))

celltype_colors <- setNames(
  lapply(seq_along(celltype_names), function(i) {
    colorRamp2(range(all_celltype_props[[i]], na.rm = TRUE), c("white", hues[i]))
  }),
  celltype_names
)

# Step 4: Create row annotation for all cell types - add CTVT from chunk above back in!
multi_celltype_annotation <- rowAnnotation(
  df = cbind(all_celltype_props, 
             CTVT_proportion = annot_df$CTVT_snProportion),
  col = c(celltype_colors, 
          CTVT_proportion = colorRamp2(
    range(annot_df$CTVT_snProportion, na.rm = TRUE),
    c("white", "purple"))),
  annotation_name_side = "top"
)

# Step 5: Combine with CTVT annotation if you want both
combined_row_ha <- multi_celltype_annotation  # replace with next line if you want both
# combined_row_ha <- row_ha + multi_celltype_annotation

# Step 6: Add annotation to Heatmap
ht <- Heatmap(
  rmseMat,
  name = "Median RMSE",
  col = rmse_col_fun,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  row_names_gp = gpar(fontsize = 8),
  column_names_gp = gpar(fontsize = 8),
  left_annotation = combined_row_ha,
  heatmap_legend_param = list(title = "RMSE"),
  cell_fun = function(j, i, x, y, width, height, fill){
    grid.text(sprintf("%.1f", rmseMat[i, j]), x, y, gp = gpar(fontsize = 6))}
)

# Step 7: Output to PDF
pdf(paste0(plotDir, "/heatmaps/", fprefix, "_medianRmse_withAllCelltypeProps.pdf"), 
    height = 8, width = 16)

print(ht)

dev.off()
```



## 2.3 Granular metrics
### 2.3.1 Per cell type
```{r}

```

#### 2.3.1.1 MAE
```{r}

```

#### 2.3.1.2 RMSE
```{r}

```

#### 2.3.1.3 RPE
```{r}

```

## 2.4 Proportion df
```{r}
# plotDirHmPropDf <- paste0(plotDir, "/heatmaps/propDf/")
cellTypeOrder <- c("CTVT_cells", "CAFs", "Endothelial_cells",
                   "Mono.Macro.DC", "Plasma_cells",  "T_cells")
```

### 2.4.1 Full reference
Was testing the function on just the reference with all cells and all genes ("snCounts"). 
This is built into the loop in ### 2.4.2
See 01_Deconvolution_musicLOO.Rmd for all details. 

### 2.4.2 All sn+bc+bn reference proportion heatmaps
Outer loop --> reference. 
Inner loop --> method param reference.
Read in masterPropDf from Chunk ### 2.4.2
#### 2.4.2.1 Global arguments
```{r}
cellTypeOrder <- c("CTVT_cells", "CAFs", "Endothelial_cells",
                   "Mono.Macro.DC", "Plasma_cells",  "T_cells")

sampleGroups <- list(
  c("All samples", "Reference"),
  c("sn_3176T3", "bn_3176T3", "bc_3176T3"),
  c("sn_3177T2", "bn_3177T2", "bc_3177T2"),
  c("bc_3177T4", "bn_3177T4"),
  c("bn_3177T5", "bc_3177T5"),
  c("bn_3177T6", "bc_3177T6"),
  c("sn_3178T1", "bn_3178T1", "bc_3178T1"),
  c("sn_3179T2", "bn_3179T2", "bc_3179T2"),
  c("sn_3179T3", "bn_3179T3", "bc_3179T3"),
  c("sn_3180T3", "bn_3180T3", "bc_3180T3"),
  c("sn_3181T1", "bn_3181T1", "bc_3181T1")
)

# Flatten list to get sampleOrder (same as yours)
sampleOrder <- unlist(sampleGroups)

# Determine where to insert gaps: after each group
rowGaps <- unit(rep(5, length(sampleGroups) - 1), "pt")

refProp <- read.xlsx(paste0(wDir, "13_Results/relativeProportionCellTypesPerReference.xlsx")) %>%
  column_to_rownames("cellTypes") %>%
  as.data.frame()

# Filter only "sn" samples for true proportions df. Never changes. 
snDf <- masterPropDf %>%
    filter(sampleType == "sn")%>%
    mutate(typeName = paste0(sampleType,"_", sampleNameEdit))
```

#### 2.4.2.2 Loop through references and plot
```{r}
print(unique(masterPropDf$Reference))

for (ref in unique(masterPropDf$Reference)){
  
  print(paste0("Running reference: ", ref))
  
  # Create heatmap directory for this reference. 
  plotDirHmPropDf <- paste0(plotDir, "/heatmaps/", ref, "/")
  
  # Will not overwrite any existing directories. 
  dir.create(plotDirHmPropDf)
  
  #########################
  # Get "All samples" and "Reference" cell type proportions. 
  #########################
  
  # if ref == "snCounts" bind fullRef twice. otherwise bind appropriate LOO. 
  refDf <- NULL
  if (ref == "snCounts"){
    refDf <- cbind(refProp$fullRef, refProp$fullRef) %>%
      t()
    
    # Add rownames back! 
    colnames(refDf) <- rownames(refProp)
    rownames(refDf) <- c("fullRef", "snCounts")
  }else{
    refDf <- refProp %>%
      select(c(fullRef, ref)) %>%
      t()
  }

  # To match sampleGroup names and order. 
  rownames(refDf) <- c("All samples", "Reference")
  
  # To match cell type order in heatmapMatrix.
  refDf <- refDf[,cellTypeOrder]
  
  #########################
  # Subset masterPropDf on reference for creating heatmapMatrix.
  #########################
  
  # Add column for heatmap rownames to match sampleGroups. 
  masterPropDfEdit <- masterPropDf %>%
    filter(Reference==ref) %>%
    mutate(typeName = paste0(sampleType,"_", sampleNameEdit))
  
  # Remainer of results df. 
  resDf <- masterPropDfEdit %>%
    filter(sampleType != "sn")

  ###########################################
  ### Loop through Method_Param_Reference ###
  ### Multiple parameters possible per reference 
  ### Scripts are split by method so not really looping through methods rn. 
  ###########################################

  for (mpr in unique(resDf$Method_Param_Reference)){
    
    print(mpr)
    
    # Rbind results and ground truth. 
    tempPlotDf <- resDf %>%
      filter(Method_Param_Reference == mpr) %>%
      rbind(snDf) 
    
    # Check to make sure all typeNames have all cell types in df
    all_counts_equal <- length(unique(table(tempPlotDf$typeName))) == 1
    if (all_counts_equal==FALSE) {
      cat("❌ typeName groups have unequal counts.\n")
      print(table(tempPlotDf$typeName))  # Optional: see where they differ
    }
  
    # Pivot to wide format
    heatmapMatrix <- tempPlotDf %>%
      select(typeName, manual.log.anot.fine, cellProportion) %>%
      pivot_wider(names_from = manual.log.anot.fine, values_from = cellProportion) %>%
      # Use mutated seq type _ sample name edit for new row names.
      column_to_rownames("typeName") %>%
      select(cellTypeOrder) %>%
      as.matrix() %>%
      rbind(refDf)
    
    # Check to make sure all rownames are included in the ordering column of the samples in the heatmap. 
    diff <- setdiff(rownames(heatmapMatrix), sampleOrder)
    if (length(diff)!=0) {
      cat("❌ Missing sample names in sampleOrder")
      print(diff)
    }
    
    # Check to make sure all ordering columns are in rownames. 
    diff <- setdiff(sampleOrder, rownames(heatmapMatrix))
    if (length(diff)!=0) {
      cat("❌ Missing sampleOrder names in heatMapmatrix rownames.")
      print(diff)  
    }
    
    # Reorder for plotting
    heatmapMatrix <- heatmapMatrix[sampleOrder, cellTypeOrder]
    
    # Ensure that the color vector matches matrix columns
    cellTypes <- colnames(heatmapMatrix)
    stopifnot(all(cellTypes %in% names(manualColors)))
    
    # Create column-specific color functions: white → manual hue
    col_fun_list <- setNames(
      lapply(cellTypes, function(cell) {
        vals <- heatmapMatrix[, cell]
        colorRamp2(
          c(min(vals, na.rm = TRUE), max(vals, na.rm = TRUE)),
          c("white", manualColors[[cell]])
        )
      }),
      cellTypes
    )
    
    # Create a heatmap per cell type
    heatmap_list <- lapply(cellTypes, function(cell) {
      Heatmap(heatmapMatrix[, cell, drop = FALSE],
              name = cell,
              col = col_fun_list[[cell]],
              cluster_rows = FALSE,
              cluster_columns = FALSE,
              show_row_names = TRUE,
              show_column_names = TRUE, 
              column_names_rot = 45, 
              row_gap = rowGaps,
              row_split = rep(seq_along(sampleGroups), lengths(sampleGroups)))
    })
    
    # Combine and draw the full heatmap
    combinedHeatmap <- Reduce(`+`, heatmap_list)
    
    pdf(paste0(plotDirHmPropDf, fprefix,"_", ref,  mpr, "_proportions.pdf"), 
        height=10, 
        width = 10)
    draw(combinedHeatmap, 
         heatmap_legend_side = "top", 
         column_title = mpr, 
         column_title_side = "bottom",
         column_title_gp = gpar(fontsize = 14, fontface = "bold")) 
    dev.off()
  }
  
}

```






