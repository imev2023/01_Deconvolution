---
title: "03_Deconvolution_CTVT_cibersort"
output: html_document
---

# 0 Environment
## 0.1 Packages
### 0.1.1 Installs
```{r echo=F, message=F, warning=FALSE}
# devtools::install_github('xuranw/MuSiC')
```
### 0.1.1 Library
```{r echo=F, message=F, warning=FALSE}
set.seed(123)
library(MuSiC)
library(tidyverse)
library(SingleCellExperiment)
library(openxlsx)
library(dplyr)
library(Seurat)
library(Biobase)
```

## 0.2 Paths
```{r echo=F, message=FALSE, warning=FALSE}
fprefix <- "03_Deconvolution_CTVT_music"
wDir <- paste0("~/gitClones/01_Deconvolution/03_Deconvolution_CTVT/")
dataDir <- paste0(wDir, "/031_Data/")
resDir <- paste0(wDir, "/033_Results/", fprefix, "/")
plotDir <- paste0(wDir, "/034_Plots/", fprefix, "/")

dir.create(resDir)
dir.create(plotDir)
```

### 0.3.3 Metrics
```{r}
# source(paste0(wDir, "/12_Scripts/01_Deconvolution_deconBenchmark_metricFunctions.R"))
```

# 1.0 Inputs
BayesPrism will take intersect of genes in reference and bulk samples.
Use unnormalized and untransformed count data.
## 1.1 Marker genes
```{r}
masterMarkerGenes <- read.xlsx("~/gitClones/01_Deconvolution/03_Deconvolution_CTVT/033_Results/03_Deconvolution_CTVT_geneCorrelations/03_Deconvolution_CTVT_geneCorrelations_masterMarkerGenes.xlsx")
  
geneDict <- masterMarkerGenes %>%
  select(Symbol, GeneID) %>%
  # Take distinct as marker genes may overlap clusters.
  distinct()

uniqueGeneDict <- masterMarkerGenes %>%
  filter(Unique=="Unique") %>%
  select(Symbol, GeneID) %>%
  # Take distinct as marker genes may overlap clusters.
  distinct()

table(masterMarkerGenes$cluster)

# 
#   Bcells CAF.Endo     CTVT  Myeloid   Plasma   Tcells 
#       12       97       15       72       15        6 


curated <- masterMarkerGenes %>%
  filter(cluster %in% c("Bcells",
                        "CTVT",
                        "Plasma",
                        "Tcells")|
           Symbol %in% c(topCAFEndo[1:20,]$Symbol,
                         topMyeloid[1:20,]$Symbol))

table(curated$cluster)

cibersortMin50Genes2to10 <- read_table("~/gitClones/01_Deconvolution/03_Deconvolution_CTVT/033_Results/03_Deconvolution_CTVT_cibersort/snCountsFinalq1q4/sigMatrix_minExpr50_minGenes2to10/CIBERSORTx_Job46_03_Deconvolution_CTVT_cibersort_snCountsFinal_snAnno_inferred_phenoclasses.CIBERSORTx_Job46_03_Deconvolution_CTVT_cibersort_snCountsFinal_snAnno_inferred_refsample.bm.K999.txt")

cibersortDictMin50 <- masterMarkerGenes %>%
  filter(Symbol %in% cibersortMin50Genes2to10$NAME) %>%
  select(Symbol, GeneID) %>%
  # Take distinct as marker genes may overlap clusters.
  distinct()

cibersortUniqueDictMin50 <- masterMarkerGenes %>%
  filter(Symbol %in% cibersortMin50Genes2to10$NAME & Unique == "Unique") %>%
  select(Symbol, GeneID) %>%
  # Take distinct as marker genes may overlap clusters.
  distinct()


cibersortMin10Genes2to10 <- read_table("~/gitClones/01_Deconvolution/03_Deconvolution_CTVT/033_Results/03_Deconvolution_CTVT_cibersort/snCountsFinalq1q4/sigMatrix_minExpr10_minGenes2to10/CIBERSORTx_Job42_03_Deconvolution_CTVT_cibersort_snCountsFinal_snAnno_inferred_phenoclasses.CIBERSORTx_Job42_03_Deconvolution_CTVT_cibersort_snCountsFinal_snAnno_inferred_refsample.bm.K999.txt")

cibersortDictMin10 <- masterMarkerGenes %>%
  filter(Symbol %in% cibersortMin10Genes2to10$NAME) %>%
  select(Symbol, GeneID) %>%
  # Take distinct as marker genes may overlap clusters.
  distinct()

cibersortUniqueDictMin10 <- masterMarkerGenes %>%
  filter(Symbol %in% cibersortMin10Genes2to10$NAME & Unique == "Unique") %>%
  select(Symbol, GeneID) %>%
  # Take distinct as marker genes may overlap clusters.
  distinct()
```
## 1.2 Curated Marker Genes
Using DEGs
```{r}
resTypeMatched <- read.xlsx(paste0( "~/gitClones/01_Deconvolution/03_Deconvolution_CTVT/033_Results/03_Deconvolution_CTVT_DESEQ/03_Deconvolution_CTVT_DESEQ_resTypeMatched.xlsx"))

resTypeMatchedDegs <- resTypeMatched %>%
  as.data.frame() %>%
  filter(abs(log2FoldChange) >= 2.0 & padj < 0.05) 

curatedMarkers <- masterMarkerGenes %>%
  filter(GeneID != intersect(resTypeMatchedDegs$GeneID, masterMarkerGenes$GeneID))

curatedMarkersUnique <- masterMarkerGenes %>%
  filter(GeneID != intersect(resTypeMatchedDegs$GeneID, masterMarkerGenes$GeneID))
  
# intersect(resTypeMatchedDegs$GeneID, cibersortDictMin10$GeneID) --> 0
# [1] "ENSCAFG00000032358"

curatedCib10 <- cibersortDictMin10 

curatedCib10Unique <- cibersortUniqueDictMin10

intersect(resTypeMatchedDegs$GeneID, cibersortDictMin50$GeneID)

curatedCib50 <- cibersortDictMin50 %>%
  filter(GeneID != intersect(resTypeMatchedDegs$GeneID, cibersortDictMin50$GeneID))

curatedCib50Unique <- cibersortUniqueDictMin50 %>%
  filter(GeneID != intersect(resTypeMatchedDegs$GeneID, cibersortUniqueDictMin50$GeneID))
```



## 1.1 Reference
Reference - cellxgene dense matrix.
### 1.1.1 SCE
```{r}
obj <- readRDS(paste0(dataDir, "SCE_concat_CTVT_includingAllGenes_logCorrecDone_vstCorrecDone_ClustDone2_ManAnot.rds"))

objNoBad <- obj[,obj$manual.log.anot.fine!="bad"]

rm(obj)
gc()

rowDataHvgs <- rowData(objNoBad) %>%
as.data.frame() %>%
  filter(hvgs ==TRUE)

snCountsFinal_colData <- colData(objNoBad)

snAnno <- snCountsFinal_colData$manual.log.anot.fine %>%
  as.data.frame()

print(sort(table(snAnno)))

# Create the cell count matrix: rows = cell types, columns = samples
snCellCountsNoBad <- snCountsFinal_colData %>%
  as.data.frame() %>%
  group_by(manual.log.anot.fine,
           Sample) %>%
  summarise(cellCount = n()) %>%
  pivot_wider(names_from = Sample,
              values_from = cellCount,
              values_fill = 0) %>%
  column_to_rownames("manual.log.anot.fine")

snCellPropNoBad <- apply(snCellCountsNoBad, 2, function(x) x/sum(x))

colSums(snCellPropNoBad) # Should all be 1.

write.xlsx(snCellCountsNoBad %>% rownames_to_column("Cluster"), paste0(dataDir, "01_Deconvolution_CTVT_seuratObjNoBad_snCellCounts.xlsx"))

test <- read.xlsx( paste0(dataDir, "01_Deconvolution_CTVT_seuratObjNoBad_snCellCounts.xlsx"))

# df = data.frame(cellNames = snAnno, Sample = snCountsFinal_colData$Sample)
# row.names(df) <- row.names(snCountsFinal_colData)
# df = new("AnnotatedDataFrame", data = df) # Cell type identities are stored as an AnnotatedDataFrame
# 
# # Creating an ExpressionSet from the single cell matrix
# scDataMatrix = Matrix::as.matrix(counts(objNoBad))[geneDict$Symbol,]
# 
# scDataMatrix = scDataMatrix[rowSums(scDataMatrix)>0,] # Removing genes with no reads
# 
# SCDataES <- Biobase::ExpressionSet(assayData=scDataMatrix, phenoData = df, protocolData = df)
```

### 1.1.2 Downsample
```{r}
# #randomly downsample the subset data to obtain equal number of cells in each celltype
# set.seed(123)
# 
# 
# assay(objNoBad, "counts") <- as.matrix(assay(objNoBad, "counts"))
# assay(objNoBad, "logcounts") <- as.matrix(assay(objNoBad, "logcounts"))
# seuratObjNoBad <- as.Seurat(objNoBad, counts = "counts", data = "logcounts")
# 
# Idents(seuratObjNoBad) <- "manual.log.anot.fine"
# 
# seuratObjNoBadDs <- subset(seuratObjNoBad, downsample = 500)
# 
# snAnnoDs <- seuratObjNoBadDs$manual.log.anot.fine
# 
# # > table(seuratObjNoBadDs$manual.log.anot.fine)
# # 
# #   Bcells CAF.Endo     CTVT  Myeloid   Plasma   Tcells 
# #      500      500      500      500      310      500 
# 
# snCountsFinal <- as.matrix(assay(objNoBad, "counts"))
```


### 1.1.2 Cell type annotations
Cell type labels - character vector same length as # cells in reference.
Cell state labels - optional, finer granularity character vector. (i.e. myeloid 1 vs myeloid 2). 
Labels should have at least 20 to 50 cells. 
```{r}

```

## 1.3 Bulk
### 1.2.1 Matrix
```{r}
bulkCountsFinal <- readRDS(paste0(dataDir,
                                  "01_Deconvolution_matchedBulkMatrixCTVT_bulkCountsFinal.rds")) %>%
  as.data.frame() %>%
  rownames_to_column("GeneID") %>%
  filter(GeneID %in% geneDict$GeneID) %>%
  left_join(geneDict) %>%
  column_to_rownames("Symbol") %>%
  select(-GeneID) %>%
  as.matrix()

# bulkCountsES <- Biobase::ExpressionSet(assayData=as.matrix(bulkCountsFinal)) # Creating an ExpressionSet from the bulk matrix
```

### 1.3.2 Metadata
```{r}
bulkCountsFinal_metadata <- read.xlsx(paste0(dataDir, "01_Deconvolution_matchedBulkMatrixCTVT_bulkCountsFinal_metadata.xlsx"))
```

# 2 Prepare MuSiC
## 2.1 Basis
### 2.1.1 All genes --> TODO MAP!
```{r}
# # Produce the first step information
# basis = music_basis(objNoBad, 
#                     clusters = 'manual.log.anot.fine',
#                     samples = 'sampleID', 
#                     select.ct = unique(snAnno))
# 
# # Plot the dendrogram of design matrix and cross-subject mean of realtive abundance
# par(mfrow = c(1, 2))
# d <- dist(t(log(Mousesub.basis$Disgn.mtx + 1e-6)), method = "euclidean")
# # Hierarchical clustering using Complete Linkage
# hc1 <- hclust(d, method = "complete" )
# # Plot the obtained dendrogram
# plot(hc1, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix)')
# d <- dist(t(log(Mousesub.basis$M.theta + 1e-8)), method = "euclidean")
# # Hierarchical clustering using Complete Linkage
# # hc2 <- hclust(d, method = "complete" )
# hc2 <- hclust(d, method = "complete")
# # Plot the obtained dendrogram
# plot(hc2, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA)')
```

### 2.1.2 All markers
```{r}
# Produce the first step information
basisMarkers = music_basis(objNoBad, 
                    clusters = 'manual.log.anot.fine',
                    samples = 'Sample', 
                    select.ct = unique(snAnno$.),
                    markers = geneDict$Symbol)

# Plot the dendrogram of design matrix and cross-subject mean of realtive abundance
par(mfrow = c(1, 2))
d <- dist(t(log(basisMarkers$Disgn.mtx + 1e-6)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
hc1 <- hclust(d, method = "complete" )
# Plot the obtained dendrogram
plot(hc1, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix)')
d <- dist(t(log(basisMarkers$M.theta + 1e-8)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
# hc2 <- hclust(d, method = "complete" )
hc2 <- hclust(d, method = "complete")
# Plot the obtained dendrogram
plot(hc2, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA) basisMarkers')


pdf(paste0(plotDir, "/dendro/", fprefix, "_clusterBasisMarkers.pdf"))
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisMarkers')
plot(hc4, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA) basisMarkers')
dev.off()
```

### 2.1.3 Unique markers
```{r}
# Produce the first step information
basisUnique = music_basis(objNoBad, 
                    clusters = 'manual.log.anot.fine',
                    samples = 'Sample', 
                    select.ct = unique(snAnno$.), 
                    markers = uniqueGeneDict$Symbol)

# Plot the dendrogram of design matrix and cross-subject mean of realtive abundance
par(mfrow = c(1, 2))
d <- dist(t(log(basisUnique$Disgn.mtx + 1e-6)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
hc3 <- hclust(d, method = "complete" )
# Plot the obtained dendrogram
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisUnique')
d <- dist(t(log(basisUnique$M.theta + 1e-8)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
# hc2 <- hclust(d, method = "complete" )
hc4 <- hclust(d, method = "complete")
# Plot the obtained dendrogram
plot(hc4, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA) basisUnique')

pdf(paste0(plotDir, "/dendro/", fprefix, "_clusterBasisUnique.pdf"))
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisUnique')
plot(hc4, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA) basisUnique')
dev.off()
```

### 2.1.4 Curated
```{r}
# Produce the first step information
basisCurated = music_basis(objNoBad, 
                    clusters = 'manual.log.anot.fine',
                    samples = 'Sample', 
                    select.ct = unique(snAnno$.), 
                    markers = curatedDict$Symbol)

# Plot the dendrogram of design matrix and cross-subject mean of realtive abundance
par(mfrow = c(1, 2))
d <- dist(t(log(basisCurated$Disgn.mtx + 1e-6)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
hc3 <- hclust(d, method = "complete" )
# Plot the obtained dendrogram
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisCurated')
d <- dist(t(log(basisCurated$M.theta + 1e-8)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
# hc2 <- hclust(d, method = "complete" )
hc4 <- hclust(d, method = "complete")
# Plot the obtained dendrogram

pdf(paste0(plotDir, "/dendro/", fprefix, "_clusterBasisCurated.pdf"))
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisCurated')
plot(hc4, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA) basisCurated')
dev.off()
```


### 2.1.5 Curated unique
```{r}
# Produce the first step information
basisCuratedUnique = music_basis(objNoBad, 
                    clusters = 'manual.log.anot.fine',
                    samples = 'Sample', 
                    select.ct = unique(snAnno$.), 
                    markers = curatedUniqueDict$Symbol)

# Plot the dendrogram of design matrix and cross-subject mean of realtive abundance
par(mfrow = c(1, 2))
d <- dist(t(log(basisCuratedUnique$Disgn.mtx + 1e-6)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
hc3 <- hclust(d, method = "complete" )
# Plot the obtained dendrogram
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisUniqueCurated')
d <- dist(t(log(basisCuratedUnique$M.theta + 1e-8)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
# hc2 <- hclust(d, method = "complete" )
hc4 <- hclust(d, method = "complete")
# Plot the obtained dendrogram

pdf(paste0(plotDir, "/dendro/", fprefix, "_clusterBasisCuratedUnique.pdf"))
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisCuratedUnique')
plot(hc4, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA) basisCuratedUnique')
dev.off()


```

### 2.1.6 CibersortX
#### 2.1.6.1 Min 50
##### 2.1.6.1.1 All
```{r}
# Produce the first step information
basisCibersort = music_basis(objNoBad, 
                    clusters = 'manual.log.anot.fine',
                    samples = 'Sample', 
                    select.ct = unique(snAnno$.), 
                    markers = cibersortDict$Symbol)

# Plot the dendrogram of design matrix and cross-subject mean of realtive abundance
par(mfrow = c(1, 2))
d <- dist(t(log(basisCibersort$Disgn.mtx + 1e-6)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
hc3 <- hclust(d, method = "complete" )
# Plot the obtained dendrogram
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisUniqueCurated')
d <- dist(t(log(basisCibersort$M.theta + 1e-8)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
# hc2 <- hclust(d, method = "complete" )
hc4 <- hclust(d, method = "complete")
# Plot the obtained dendrogram

pdf(paste0(plotDir, "/dendro/", fprefix, "_clusterBasisCibersortMin50.pdf"))
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisCibersort min 50')
plot(hc4, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA) basisCibersort min 50')
dev.off()
```

##### 2.1.6.1.2 Unique
```{r}
# Produce the first step information
basisCibersortUnique = music_basis(objNoBad, 
                    clusters = 'manual.log.anot.fine',
                    samples = 'Sample', 
                    select.ct = unique(snAnno$.), 
                    markers = cibersortUniqueDict$Symbol)

# Plot the dendrogram of design matrix and cross-subject mean of realtive abundance
par(mfrow = c(1, 2))
d <- dist(t(log(basisCibersortUnique$Disgn.mtx + 1e-6)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
hc3 <- hclust(d, method = "complete" )
# Plot the obtained dendrogram
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisUniqueCurated')
d <- dist(t(log(basisCibersortUnique$M.theta + 1e-8)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
# hc2 <- hclust(d, method = "complete" )
hc4 <- hclust(d, method = "complete")
# Plot the obtained dendrogram

pdf(paste0(plotDir, "/dendro/", fprefix, "_clusterBasisCibersortMin50Unique.pdf"))
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisCibersortUnique min50')
plot(hc4, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA) basisCibersortUnique min50')
dev.off()
```

#### 2.1.6.1 Min 10
##### 2.1.6.2.1 All
```{r}
# Produce the first step information
basisCibersortMin10 = music_basis(objNoBad, 
                    clusters = 'manual.log.anot.fine',
                    samples = 'Sample', 
                    select.ct = unique(snAnno$.), 
                    markers = cibersortDictMin10$Symbol)

# Plot the dendrogram of design matrix and cross-subject mean of realtive abundance
par(mfrow = c(1, 2))
d <- dist(t(log(basisCibersortMin10$Disgn.mtx + 1e-6)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
hc3 <- hclust(d, method = "complete" )
# Plot the obtained dendrogram
d <- dist(t(log(basisCibersortMin10$M.theta + 1e-8)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
# hc2 <- hclust(d, method = "complete" )
hc4 <- hclust(d, method = "complete")
# Plot the obtained dendrogram

pdf(paste0(plotDir, "/dendro/", fprefix, "_clusterbasisCibersortMin10.pdf"))
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisCibersort Min10')
plot(hc4, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA) basisCibersort Min10')
dev.off()
```

##### 2.1.6.2.2 Unique
```{r}
# Produce the first step information
basisCibersortUniqueMin10 = music_basis(objNoBad, 
                    clusters = 'manual.log.anot.fine',
                    samples = 'Sample', 
                    select.ct = unique(snAnno$.), 
                    markers = cibersortUniqueDictMin10$Symbol)

# Plot the dendrogram of design matrix and cross-subject mean of realtive abundance
par(mfrow = c(1, 2))
d <- dist(t(log(basisCibersortUniqueMin10$Disgn.mtx + 1e-6)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
hc3 <- hclust(d, method = "complete" )
# Plot the obtained dendrogram
d <- dist(t(log(basisCibersortUniqueMin10$M.theta + 1e-8)), method = "euclidean")
# Hierarchical clustering using Complete Linkage
# hc2 <- hclust(d, method = "complete" )
hc4 <- hclust(d, method = "complete")
# Plot the obtained dendrogram

pdf(paste0(plotDir, "/dendro/", fprefix, "_clusterBasisCibersortMin10Unique.pdf"))
plot(hc3, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix) basisCibersortUniqueMin10')
plot(hc4, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA) basisCibersortUniqueMin10')
dev.off()
```

## 2.2 Define clusters
### 2.2.1 All markers
Tree guided may be problematic because very nested?
```{r}
# treeGuided <- list(C1 = "Plasma",
#                    C2 = )
# 
# manualGuided <- list(C1 = c("CTVT"),
#                      C2 = c("Bcells", "Plasma", "Tcells", "Myeloid", "CAF.Endo"))
```

# 3 Estimate proportions
## 3.0 Test
```{r}
GSE50244.bulk.eset = readRDS('https://xuranw.github.io/MuSiC/data/GSE50244bulkeset.rds')
GSE50244.bulk.eset
```

## 3.1 No clustering 
```{r}

resList <- list()

```

### 3.1.1 Non-unique
```{r}
# musicRes = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
#                              sc.sce = objNoBad, 
#                              clusters = 'manual.log.anot.fine',
#                     samples = 'Sample') # Running MuSiC
# 
# saveRDS(musicRes, paste0(resDir, fprefix, "_musicRes.rds"))
# 
# resList$musicRes <- musicRes
# 
# 
# musicResCurated = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
#                              sc.sce = objNoBad, 
#                              clusters = 'manual.log.anot.fine',
#                     samples = 'Sample', 
#                     markers=curatedDict$Symbol) # Running MuSiC
# 
# saveRDS(musicResCurated, paste0(resDir, fprefix, "_musicResCurated.rds"))
# 
# resList$musicResCurated <- musicResCurated
# 
# musicResCibersort10 = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
#                              sc.sce = objNoBad, 
#                              clusters = 'manual.log.anot.fine',
#                     samples = 'Sample', 
#                     markers=cibersortDictMin10$Symbol)
# 
# saveRDS(musicResCibersort10, paste0(resDir, fprefix, "_musicResCibersort10.rds"))
# 
# resList$musicResCibersort10 <- musicResCibersort10
#   
# musicResCibersort50 = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
#                              sc.sce = objNoBad, 
#                              clusters = 'manual.log.anot.fine',
#                     samples = 'Sample', 
#                     markers=cibersortDictMin50$Symbol)
# saveRDS(musicResCibersort50, paste0(resDir, fprefix, "_musicResCibersort50.rds"))
# 
# resList$musicResCibersort50 <- musicResCibersort50
```
### 3.1.2 Unique
```{r}
# musicResUnique = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
#                              sc.sce = objNoBad, 
#                              clusters = 'manual.log.anot.fine',
#                     samples = 'Sample',
#                     markers=uniqueGeneDict$Symbol) # Running MuSiC
# saveRDS(musicRes, paste0(resDir, fprefix, "_musicResUnique.rds"))
# 
# resList$musicResUnique <- musicResUnique
# 
# musicResCuratedUnique = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
#                              sc.sce = objNoBad, 
#                              clusters = 'manual.log.anot.fine',
#                     samples = 'Sample',
#                     markers=curatedUniqueDict$Symbol) # Running MuSiC
# 
# saveRDS(musicResCuratedUnique, paste0(resDir, fprefix, "_musicResCuratedUnique.rds"))
# 
# resList$musicResCuratedUnique <- musicResCuratedUnique
# 
# musicResCibersort10Unique = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
#                              sc.sce = objNoBad, 
#                              clusters = 'manual.log.anot.fine',
#                     samples = 'Sample', 
#                     markers=cibersortUniqueDictMin10$Symbol)
# 
# saveRDS(musicResCibersort10Unique, paste0(resDir, fprefix, "_musicResCibersort10Unique.rds"))
# 
# resList$musicResCibersort10Unique <- musicResCibersort10Unique
#   
# musicResCibersort50Unique = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
#                              sc.sce = objNoBad, 
#                              clusters = 'manual.log.anot.fine',
#                     samples = 'Sample', 
#                     markers=cibersortUniqueDictMin50$Symbol)
# saveRDS(musicResCibersort50Unique , paste0(resDir, fprefix, "_musicResCibersort50Unique .rds"))
# 
# resList$musicResCibersort50Unique <- musicResCibersort50Unique
```


## 3.2 CTVT vs Other
```{r}
resList <- list()

clusters <- list(C1 = "CTVT",
                 C2 = c("Bcells", "Tcells", "Myeloid", "CAF.Endo", "Plasma"))


cl.type = as.character(objNoBad$manual.log.anot.fine)

for(cl in 1:length(clusters)){
  cl.type[cl.type %in% clusters[[cl]]] = names(clusters)[cl]
}

objNoBad$clusterType = factor(cl.type, levels = c(names(clusters)))

unlist(clusters)

# We now construct the list of group marker
nonuniqueCTVTMarkers <- masterMarkerGenes %>%
  filter(cluster == "CTVT" & Unique == "Unique") %>%
  distinct()

uniqueCTVTMarkers <- masterMarkerGenes %>%
  filter(cluster == "CTVT") %>%
  distinct()


uniqueCTVTMarkersCibersort10 <- masterMarkerGenes %>%
  filter(Symbol %in% cibersortUniqueDictMin10$Symbol) %>%
  distinct()

uniqueCTVTMarkersCibersort50 <- masterMarkerGenes %>%
  filter(Symbol %in% cibersortUniqueDictMin50$Symbol) %>%
  distinct()

uniqueOther <- masterMarkerGenes %>%
  filter(cluster != "CTVT" & Unique == "Unique") %>%
  distinct()

uniqueOtherCibersort10 <- masterMarkerGenes %>%
  filter(cluster != "CTVT" & Unique == "Unique" & Symbol %in% cibersortUniqueDictMin10$Symbol) %>%
  distinct()

uniqueOtherCibersort50 <- masterMarkerGenes %>%
  filter(cluster != "CTVT" & Unique == "Unique" & Symbol %in% cibersortUniqueDictMin50$Symbol) %>%
  distinct()

# Change from NULL to remaining genes? Or is that implied?

# markers = list(nonuniqueCTVTMarkers$Symbol, NULL)
# names(markers) = c('C1', 'C2')

markersUnique = list(uniqueCTVTMarkers$Symbol, uniqueOther$Symbol)
names(markersUnique) = c('C1', 'C2')

markersUniqueCibersort50 = list(uniqueCTVTMarkersCibersort50$Symbol, uniqueOtherCibersort50$Symbol)
names(markersUniqueCibersort50) = c('C1', 'C2')

markersUniqueCibersort10 = list(uniqueCTVTMarkersCibersort10$Symbol, uniqueOtherCibersort10$Symbol)
names(markersUniqueCibersort10) = c('C1', 'C2')
# 
# # The name of group markers should be the same as the cluster names
# test = music_prop.cluster(bulk.mtx = bulkCountsFinal,
#                           sc.sce = objNoBad,
#                           group.markers = markersUnique, 
#                           samples = 'Sample',
#                           groups = 'clusterType', 
#                           clusters = 'manual.log.anot.fine', 
#                           clusters.type = clusters,
#                           markers=geneDict$Symbol)
```

### 3.2.1 Non-unique
```{r}
musicRes = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
                             sc.sce = objNoBad,
                             group.markers = markersUnique, 
                            samples = 'Sample',
                            groups = 'clusterType', 
                            clusters = 'manual.log.anot.fine', 
                            clusters.type = clusters,
                            markers=geneDict$Symbol)

resList$musicRes <- musicRes

# musicResCurated = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
#                              sc.sce = objNoBad,
#                              group.markers = markersUnique, 
#                           samples = 'Sample',
#                           groups = 'clusterType', 
#                           clusters = 'manual.log.anot.fine', 
#                           clusters.type = clusters,
#                     markers=curatedDict$Symbol) # Running MuSiC
# 
# 
# resList$musicResCurated <- musicResCurated

musicResCibersort10 = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
                             sc.sce = objNoBad,
                             group.markers = markersUniqueCibersort10, 
                          samples = 'Sample',
                          groups = 'clusterType', 
                          clusters = 'manual.log.anot.fine', 
                          clusters.type = clusters,
                    markers=cibersortDictMin10$Symbol)

resList$musicResCibersort10 <- musicResCibersort10

musicResCibersort50 = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
                             sc.sce = objNoBad,
                            group.markers = markersUniqueCibersort50, 
                          samples = 'Sample',
                          groups = 'clusterType', 
                          clusters = 'manual.log.anot.fine', 
                          clusters.type = clusters,
                    markers=cibersortDictMin50$Symbol)

resList$musicResCibersort50 <- musicResCibersort50
```
### 3.2.2 Unique
```{r}
musicResUnique = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
                             sc.sce = objNoBad,
                             group.markers = markersUnique, 
                          samples = 'Sample',
                          groups = 'clusterType', 
                          clusters = 'manual.log.anot.fine', 
                          clusters.type = clusters,
                    markers=uniqueGeneDict$Symbol) # Running MuSiC

resList$musicResUnique <- musicResUnique

# musicResCuratedUnique = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
#                              sc.sce = objNoBad,
#                              group.markers = markersUnique, 
#                           samples = 'Sample',
#                           groups = 'clusterType', 
#                           clusters = 'manual.log.anot.fine', 
#                           clusters.type = clusters,
#                     markers=curatedUniqueDict$Symbol) # Running MuSiC
# 
# 
# resList$musicResCuratedUnique <- musicResCuratedUnique

musicResCibersort10Unique = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
                             sc.sce = objNoBad,
                             group.markers = markersUniqueCibersort10, 
                          samples = 'Sample',
                          groups = 'clusterType', 
                          clusters = 'manual.log.anot.fine', 
                          clusters.type = clusters,
                    markers=cibersortUniqueDictMin10$Symbol)



resList$musicResCibersort10Unique <- musicResCibersort10Unique

musicResCibersort50Unique = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
                             sc.sce = objNoBad,
                             group.markers = markersUniqueCibersort50, 
                          samples = 'Sample',
                          groups = 'clusterType', 
                          clusters = 'manual.log.anot.fine', 
                          clusters.type = clusters,
                    markers=cibersortUniqueDictMin50$Symbol)

resList$musicResCibersort50Unique <- musicResCibersort50Unique


saveRDS(resList, paste0(resDir, fprefix, "_musicResAll_manualTree.rds"))
```


## 3.3 Curated 
```{r}
resList <- list()

clusters <- list(C1 = "CTVT",
                 C2 = c("Bcells", "Tcells", "Myeloid", "CAF.Endo", "Plasma"))


cl.type = as.character(objNoBad$manual.log.anot.fine)

for(cl in 1:length(clusters)){
  cl.type[cl.type %in% clusters[[cl]]] = names(clusters)[cl]
}

objNoBad$clusterType = factor(cl.type, levels = c(names(clusters)))

unlist(clusters)



# We now construct the list of group marker
curatedMarkersUniqueList <- list()

markersUnique = list(uniqueCTVTMarkers$Symbol, uniqueOther$Symbol)
names(markersUnique) = c('C1', 'C2')

markersUniqueCibersort50 = list(uniqueCTVTMarkersCibersort50$Symbol, uniqueOtherCibersort50$Symbol)
names(markersUniqueCibersort50) = c('C1', 'C2')

markersUniqueCibersort10 = list(uniqueCTVTMarkersCibersort10$Symbol, uniqueOtherCibersort10$Symbol)
names(markersUniqueCibersort10) = c('C1', 'C2')
```

### 3.2.1 Non-unique
```{r}
musicResCurated = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
                             sc.sce = objNoBad,
                             group.markers = curatedMarkers,
                            samples = 'Sample',
                            groups = 'clusterType', 
                            clusters = 'manual.log.anot.fine', 
                            clusters.type = clusters,
                            markers=curatedMarkers$GeneID)

resList$musicResCurated <- musicResCurated

# musicResCurated = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
#                              sc.sce = objNoBad,
#                              group.markers = markersUnique, 
#                           samples = 'Sample',
#                           groups = 'clusterType', 
#                           clusters = 'manual.log.anot.fine', 
#                           clusters.type = clusters,
#                     markers=curatedDict$Symbol) # Running MuSiC
# 
# 
# resList$musicResCurated <- musicResCurated

musicResCibersort10 = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
                             sc.sce = objNoBad,
                             group.markers = markersUniqueCibersort10, 
                          samples = 'Sample',
                          groups = 'clusterType', 
                          clusters = 'manual.log.anot.fine', 
                          clusters.type = clusters,
                    markers=cibersortDictMin10$Symbol)

resList$musicResCibersort10 <- musicResCibersort10

musicResCibersort50 = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
                             sc.sce = objNoBad,
                            group.markers = markersUniqueCibersort50, 
                          samples = 'Sample',
                          groups = 'clusterType', 
                          clusters = 'manual.log.anot.fine', 
                          clusters.type = clusters,
                    markers=cibersortDictMin50$Symbol)

resList$musicResCibersort50 <- musicResCibersort50
```
### 3.2.2 Unique
```{r}
musicResUnique = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
                             sc.sce = objNoBad,
                             group.markers = markersUnique, 
                          samples = 'Sample',
                          groups = 'clusterType', 
                          clusters = 'manual.log.anot.fine', 
                          clusters.type = clusters,
                    markers=uniqueGeneDict$Symbol) # Running MuSiC

resList$musicResUnique <- musicResUnique

# musicResCuratedUnique = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
#                              sc.sce = objNoBad,
#                              group.markers = markersUnique, 
#                           samples = 'Sample',
#                           groups = 'clusterType', 
#                           clusters = 'manual.log.anot.fine', 
#                           clusters.type = clusters,
#                     markers=curatedUniqueDict$Symbol) # Running MuSiC
# 
# 
# resList$musicResCuratedUnique <- musicResCuratedUnique

musicResCibersort10Unique = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
                             sc.sce = objNoBad,
                             group.markers = markersUniqueCibersort10, 
                          samples = 'Sample',
                          groups = 'clusterType', 
                          clusters = 'manual.log.anot.fine', 
                          clusters.type = clusters,
                    markers=cibersortUniqueDictMin10$Symbol)



resList$musicResCibersort10Unique <- musicResCibersort10Unique

musicResCibersort50Unique = MuSiC::music_prop(bulk.mtx = bulkCountsFinal,
                             sc.sce = objNoBad,
                             group.markers = markersUniqueCibersort50, 
                          samples = 'Sample',
                          groups = 'clusterType', 
                          clusters = 'manual.log.anot.fine', 
                          clusters.type = clusters,
                    markers=cibersortUniqueDictMin50$Symbol)

resList$musicResCibersort50Unique <- musicResCibersort50Unique


saveRDS(resList, paste0(resDir, fprefix, "_musicResAll_manualTree.rds"))
```

# 4.0 Write results to masterDf
## 4.1 No tree
```{r}
resList <- readRDS(paste0(resDir, fprefix, "_musicResAll.rds"))
```

## 4.2 Maual tree
```{r}
# saveRDS(resList, paste0(resDir, fprefix, "_musicResAll_manualTree.rds"))



estimateDf <- data.frame()

nnlsDf <- data.frame()


for (i in 1:length(resListTree)){
  tempName <- str_replace(names(resList)[i], "music", "")
  
  tempMusic <- resListTree[[i]]$Est.prop.weighted %>%
    as.data.frame() %>%
    # Method details
    mutate("deconvBenchResType" = "P", # P for proportion
           "Method" = "MuSiC",
           "Reference" = tempName) # saves as string
  
  estimateDf <- rbind(estimateDf, tempMusic)
  
   tempNNLS <- resListTree[[i]]$Est.prop.allgene %>%
    as.data.frame() %>%
    # Method details
    mutate("deconvBenchResType" = "P", # P for proportion
           "Method" = "NNLS",
           "Reference" = tempName) # saves as string
  
  nnlsDf <- rbind(nnlsDf, tempNNLS)
  
}


write.xlsx(estimateDf, paste0(resDir, fprefix, "_estPropWeighted_manualTree.xlsx"))
write.xlsx(nnlsDf, paste0(resDir, fprefix, "_estPropAllgene_manualTree.xlsx"))
```

# 5 Visualizations
```{r}
# Step 2: Define a color mapping
celltype_colors <- c(
  "CTVT" = "#BCD0C7",
  "CAF.Endo" = "#FDDFA4FF",
  "Myeloid" = "#F5FDC6",
  "Plasma" = "#B4B9E0FF",
  "Tcells" = "#D56AA0",
  "Bcells" = "#A8D5E2",
  
  "CTVT - GT" = "#898980",
  "CAF.Endo - GT" = "#F9A620",
  "Myeloid - GT" = "#CACC90",
  "Plasma - GT" = "#5F5AA2",
  "Tcells - GT" = "#861657",
  "Bcells - GT" = "darkblue"
  
)

groundTruth <- snCellPropNoBad %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("Sample") %>%
  pivot_longer(cols = -c("Sample"), names_to = "Cluster", values_to = "Proportion") %>%
  mutate(
         Sample = paste0(Sample, " - GT"))


```

## 5.1 No clustering 
### 5.1.1 Bar plots
```{r}
for (i in 1:length(resList)){
  
  tempName <- str_replace(names(resList)[i], "music", "")
  
  music <- resList[[i]]$Est.prop.weighted %>%
    as.data.frame() %>%
    rownames_to_column("Sample") %>%
    pivot_longer(cols = -c("Sample"), names_to = "Cluster", values_to = "Proportion") %>%
    rbind(groundTruth) %>%
    mutate(Type = ifelse(grepl("- GT$", Sample), 
                         "Ground truth",
                         "Estimated"))

  music$Cluster <- factor(music$Cluster, levels = rev(c("CTVT", 
                                                    "Myeloid", 
                                                    "Bcells",
                                                    "CAF.Endo",
                                                    "Tcells",
                                                    "Plasma")))

  # Step 3: Plot
  musicPlot <- ggplot(
    music,
    aes(
      x = Sample,
      y = Proportion,
      fill = Cluster,
      pattern = Type  # TRUE/FALSE
    )
  ) +
  geom_bar_pattern(
    stat = "identity",
    pattern_fill = "whitesmoke",           # color of stripes
    pattern_angle = 45,               # diagonal stripes
    pattern_density = 0.01,            # small + widely spaced
    pattern_spacing = 0.01,           # space between stripes
    pattern_key_scale_factor = 0.5, 
    pattern_alpha = 0.4 # smaller legend pattern
  ) +
  scale_pattern_manual(values = c("Estimated" = "none", "Ground truth" = "stripe")) +
  scale_fill_manual(values = celltype_colors) +
  theme_minimal() +
  ylab("Estimated Proportion") +
  xlab("Sample") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle(paste0("MuSiC - ", tempName))

  
  pdf(paste0(plotDir, "/bar/", fprefix, "_music", tempName, ".pdf"),
      height=4, width=7)
  print(musicPlot)
  dev.off()
  # 
  # 
  # nnls <- resList[[i]]$Est.prop.allgene %>%
  #   as.data.frame() %>%
  #   rownames_to_column("Sample") %>%
  #   pivot_longer(cols = -c("Sample"), names_to = "Cluster", values_to = "Proportion")
  # 
  # nnls$Cluster <- factor(nnls$Cluster, levels = rev(c("CTVT", 
  #                                                   "Myeloid", 
  #                                                   "Bcells",
  #                                                   "CAF.Endo",
  #                                                   "Tcells",
  #                                                   "Plasma")))
  # 
  # # Step 3: Plot
  # nnlsPlot <- ggplot(nnls, aes(x = Sample, y = Proportion, fill = Cluster)) +
  #   geom_bar(stat = "identity") +
  #   scale_fill_manual(values = celltype_colors) +
  #   theme_minimal() +
  #   ylab("Estimated Proportion") +
  #   xlab("Sample") +
  #   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  #   ggtitle(paste0("NNLS - ", tempName))
  # 
  # pdf(paste0(plotDir, "/bar/", fprefix, "_nnls", tempName, ".pdf"),
  #     height=4, width=7)
  # print(nnlsPlot)
  # dev.off()

}
```

## 5.2 Manual clustering 
### 5.2.1 Bar plots
```{r}
resListTree <- readRDS(paste0(resDir, fprefix, "_musicResAll_manualTree.rds"))


for (i in 1:length(resListTree)){
  
  tempName <- str_replace(names(resListTree)[i], "music", "")
  
  music <- resListTree[[i]]$Est.prop.weighted %>%
    as.data.frame() %>%
    rownames_to_column("Sample") %>%
    pivot_longer(cols = -c("Sample"), names_to = "Cluster", values_to = "Proportion") %>%
    rbind(groundTruth) %>%
    mutate(Type = ifelse(grepl("- GT$", Sample), 
                         "Ground truth",
                         "Estimated"))

  music$Cluster <- factor(music$Cluster, levels = rev(c("CTVT", 
                                                    "Myeloid", 
                                                    "Bcells",
                                                    "CAF.Endo",
                                                    "Tcells",
                                                    "Plasma")))

  # Step 3: Plot
  musicPlot <- ggplot(
    music,
    aes(
      x = Sample,
      y = Proportion,
      fill = Cluster,
      pattern = Type  # TRUE/FALSE
    )
  ) +
  geom_bar_pattern(
    stat = "identity",
    pattern_fill = "whitesmoke",           # color of stripes
    pattern_angle = 45,               # diagonal stripes
    pattern_density = 0.01,            # small + widely spaced
    pattern_spacing = 0.01,           # space between stripes
    pattern_key_scale_factor = 0.5, 
    pattern_alpha = 0.4 # smaller legend pattern
  ) +
  scale_pattern_manual(values = c("Estimated" = "none", "Ground truth" = "stripe")) +
  scale_fill_manual(values = celltype_colors) +
  theme_minimal() +
  ylab("Estimated Proportion") +
  xlab("Sample") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ggtitle(paste0("MuSiC Tree - ", tempName))

  
  pdf(paste0(plotDir, "/bar/", fprefix, "_music", tempName, "_manualTree.pdf"),
      height=4, width=7)
  print(musicPlot)
  dev.off()
  
  # 
  # nnls <- resListTree[[i]]$Est.prop.allgene %>%
  #   as.data.frame() %>%
  #   rownames_to_column("Sample") %>%
  #   pivot_longer(cols = -c("Sample"), names_to = "Cluster", values_to = "Proportion")
  # 
  # nnls$Cluster <- factor(nnls$Cluster, levels = rev(c("CTVT", 
  #                                                   "Myeloid", 
  #                                                   "Bcells",
  #                                                   "CAF.Endo",
  #                                                   "Tcells",
  #                                                   "Plasma")))
  # 
  # # Step 3: Plot
  # nnlsPlot <- ggplot(nnls, aes(x = Sample, y = Proportion, fill = Cluster)) +
  #   geom_bar(stat = "identity") +
  #   scale_fill_manual(values = celltype_colors) +
  #   theme_minimal() +
  #   ylab("Estimated Proportion") +
  #   xlab("Sample") +
  #   theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  #   ggtitle(paste0("Tree - NNLS - ", tempName))
  # 
  # pdf(paste0(plotDir, "/bar/", fprefix, "_nnls", tempName, "_manualTree.pdf"),
  #     height=4, width=7)
  # print(nnlsPlot)
  # dev.off()

}
```

